--[[

 _   _    _   _   _____     _       ___     _   _   _   _   ____   
| | | |  | | | | |_   _|   / \     / _ \   | | | | | | | | | __ )  
| |_| |  | | | |   | |    / _ \   | | | |  | |_| | | | | | |  _ \  
|  _  |  | | | |   | |   / ___ \  | |_| |  |  _  | | |_| | | |_) | 
\_| |_/   \___/    \_/  /_/   \_\  \___/   \_| |_/  \___/  |____/

                        Hutao Hub
]]

---------------------------------------------------------------------------------

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/SaveManager.lua.txt"))()

local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/InterfaceManager.lua.txt"))()

local minimizeUI = Enum.KeyCode.RightAlt

-- üü¢ Create Main UI
local Window = Fluent:CreateWindow({
    Title = "Hutao Hub [Premium] | Forsaken",
    SubTitle = "Version 4.3.3",
    TabWidth = 160,
    Size = UDim2.fromOffset(480, 360),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = minimizeUI
})

-- Tabs
local Tabs = {
    Dev = Window:AddTab({ Title = "About", Icon = "rbxassetid://121302760641013"}),
    Farm = Window:AddTab({ Title = "Farm", Icon = "rbxassetid://121302760641013"}),
    Main = Window:AddTab({ Title = "Main", Icon = "rbxassetid://121302760641013" }),
    Player = Window:AddTab({ Title = "Player", Icon = "rbxassetid://121302760641013" }),
    Visual = Window:AddTab({ Title = "Visual", Icon = "rbxassetid://121302760641013" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "rbxassetid://121302760641013" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "rbxassetid://121302760641013" }),
}         

-- Tab.Dev

local Options = Fluent.Options


    Tabs.Dev:AddParagraph({
        Title = "Note",
        Content = "Thank you for using the script!"
    })

    Tabs.Dev:AddSection("‚Ü≥ Links")

    Tabs.Dev:AddButton({
        Title = "Discord",
        Description = "Copy the link to join the discord!",
        Callback = function()
            setclipboard("https://discord.gg/WEGT92yv")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })



    Tabs.Dev:AddButton({
        Title = "Youtube",
        Description = "Copy link to Subscribe to Youtube channel!",
        Callback = function()
            setclipboard("https://www.youtube.com/@SLKgamingSSR")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })


    Tabs.Dev:AddButton({
        Title = "Facebook",
        Description = "Copy link to join facebook group!",
        Callback = function()
            setclipboard("https://www.facebook.com/groups/1180845463307087/?ref=share&mibextid=NSMWBT")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })

-- Tabs.Farm





local Players = game:GetService("Players")
local PFS = game:GetService("PathfindingService")
local VIM = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LP = Players.LocalPlayer
local Spectators = {}
local currentCharacter
local isInGame, busy, isSprinting = false, false, false
local stamina, counter = 100, 0
local Killer, Survivor = false, false

-- Danh s√°ch killer nguy hi·ªÉm
local DangerousKillers = {
    ["Slasher"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- üü¢ Danh s√°ch survivor ∆∞u ti√™n (ch·ªâ khi l√† model trong Survivors)
local PriorityList = {
    ["0206octavio"] = true
}

-- H√†m l·∫•y survivor ∆∞u ti√™n
local function GetPriorityTarget(survivorsFolder)
    for _, survivor in ipairs(survivorsFolder:GetChildren()) do
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
            if PriorityList[survivor.Name] then
                local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    return survivor
                end
            end
        end
    end
    return nil
end

-- H√†m ki·ªÉm tra c√≥ killer nguy hi·ªÉm g·∫ßn generator kh√¥ng
local function isKillerNearGenerator(generatorPos, distance)
    local killersFolder = workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return false end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
            if DangerousKillers[killer.Name] then
                local dist = (killer.HumanoidRootPart.Position - generatorPos).Magnitude
                if dist <= distance then
                    return true
                end
            end
        end
    end
    return false
end

-- H√†m ki·ªÉm tra m·∫∑t ƒë·∫•t
local function safe(pos)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {workspace.Map.Ingame.Map}
    rayParams.FilterType = Enum.RaycastFilterType.Include
    local rayResult = workspace:Raycast(pos + Vector3.new(0, 5, 0), Vector3.new(0, -10, 0), rayParams)
    if rayResult then
        local yDiff = math.abs(rayResult.Position.Y - pos.Y)
        return yDiff < 5
    end
    return false
end

-- N√∫t Toggle Fluent UI
Tabs.Farm:AddToggle("AutoExpMoney", {
    Title = "Auto Farm Exp / Money",
    Default = false
})
:OnChanged(function(Value)
    _G.AutoFarm = Value

    -- C·∫≠p nh·∫≠t Spectators / InGame
    task.spawn(function()
        while _G.AutoFarm do
            Spectators = {}
            for _, v in ipairs(workspace:WaitForChild("Players"):WaitForChild("Spectating"):GetChildren()) do
                table.insert(Spectators, v.Name)
            end
            isInGame = not table.find(Spectators, LP.Name)
            task.wait(0.5)
        end
    end)

    -- X√°c ƒë·ªãnh m√¨nh l√† Killer hay Survivor
    task.spawn(function()
        while _G.AutoFarm do
            if workspace:FindFirstChild("Players") then
                local killersFolder = workspace.Players:FindFirstChild("Killers")
                local survivorsFolder = workspace.Players:FindFirstChild("Survivors")
                if killersFolder and survivorsFolder then
                    Killer = killersFolder:FindFirstChild(LP.Name) or table.find(killersFolder:GetChildren(), LP.Character)
                    Survivor = survivorsFolder:FindFirstChild(LP.Name) or table.find(survivorsFolder:GetChildren(), LP.Character)
                end
            end
            task.wait(0.5)
        end
    end)

    -- H√†nh ƒë·ªông ch√≠nh
    task.spawn(function()
        task.wait(0.5)
        local killersFolder = workspace.Players:WaitForChild("Killers")
        local survivorsFolder = workspace.Players:WaitForChild("Survivors")

        while _G.AutoFarm do
            if Killer then
                -- ∆Øu ti√™n target
                local target = GetPriorityTarget(survivorsFolder)

                -- N·∫øu kh√¥ng c√≥ th√¨ ch·ªçn survivor b·∫•t k·ª≥
                if not target then
                    for _, survivor in ipairs(survivorsFolder:GetChildren()) do
                        if survivor:IsA("Model")
                        and survivor:FindFirstChild("HumanoidRootPart")
                        and survivor:FindFirstChild("Humanoid")
                        and survivor.Humanoid.Health > 0 then
                            target = survivor
                            break
                        end
                    end
                end

                if target then
                    -- D·ªãch chuy·ªÉn theo target
                    task.spawn(function()
                        while _G.AutoFarm
                        and target
                        and target:IsDescendantOf(survivorsFolder)
                        and target:FindFirstChild("Humanoid")
                        and target.Humanoid.Health > 0 do

                            local character = LP.Character
                            if character and character:FindFirstChild("HumanoidRootPart") and target:FindFirstChild("HumanoidRootPart") then
                                character:PivotTo(target.HumanoidRootPart.CFrame)
                            end
                            task.wait(0.1)
                        end
                    end)

                    -- T·∫•n c√¥ng target
                    task.spawn(function()
                        while _G.AutoFarm
                        and target
                        and target:IsDescendantOf(survivorsFolder)
                        and target:FindFirstChild("Humanoid")
                        and target.Humanoid.Health > 0
                        and target:FindFirstChild("HumanoidRootPart") do

                            for _, key in ipairs({Enum.KeyCode.Q, Enum.KeyCode.E, Enum.KeyCode.R}) do
                                if not _G.AutoFarm then break end
                                VIM:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                                task.wait(0.05)
                                VIM:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                                VIM:SendKeyEvent(true, key, false, game)
                                task.wait(0.05)
                                VIM:SendKeyEvent(false, key, false, game)
                                task.wait(0.1)
                            end
                            task.wait(0.8)
                        end
                    end)
                else
                    task.wait(0.5)
                end

            elseif Survivor then
                if isInGame then
                    -- L·∫•y character
                    for _, surv in ipairs(survivorsFolder:GetChildren()) do
                        if surv:GetAttribute("Username") == LP.Name then
                            currentCharacter = surv
                            break
                        end
                    end

                    -- Check ch·∫øt th√¨ reset
                    task.spawn(function()
                        while _G.AutoFarm do
                            if currentCharacter and currentCharacter:FindFirstChild("Humanoid") and currentCharacter.Humanoid.Health <= 0 then
                                isInGame = false
                                isSprinting = false
                                busy = false
                                break
                            end
                            task.wait(0.5)
                        end
                    end)

                    -- L√†m generator
                    for _, gen in ipairs(workspace.Map.Ingame:WaitForChild("Map"):GetChildren()) do
                        if not _G.AutoFarm then break end
                        if gen.Name == "Generator" and gen:FindFirstChild("Progress") and gen.Progress.Value ~= 100 then

                            -- L·∫•y v·ªã tr√≠ ph√≠a tr∆∞·ªõc generator
                            local genCFrame = gen:GetPivot()
                            local goalPos = (genCFrame * CFrame.new(0, 0, -7)).Position

                            -- Anti-Killer check
                            if isKillerNearGenerator(goalPos, 50) then
                                print("‚ö†Ô∏è B·ªè qua generator v√¨ killer nguy hi·ªÉm ·ªü g·∫ßn!")
                                continue
                            end

                            if currentCharacter and currentCharacter:FindFirstChild("HumanoidRootPart") then
                                currentCharacter:PivotTo(CFrame.new(goalPos + Vector3.new(0, 5, 0))) -- ch·ªânh ƒë·ªô cao khi player teleport
                                task.wait(0.75)

                                local prompt = gen:FindFirstChild("Main") and gen.Main:FindFirstChild("Prompt")
                                if prompt then
                                    prompt.HoldDuration = 0
                                    prompt.RequiresLineOfSight = false
                                    prompt.MaxActivationDistance = 99999
                                    task.wait(0.15)

                                    pcall(function()
                                        prompt:InputHoldBegin()
                                        prompt:InputHoldEnd()
                                    end)

                                    busy = true
                                    counter = 0
                                    while _G.AutoFarm and gen.Progress.Value ~= 100 do
                                        pcall(function()
                                            prompt:InputHoldBegin()
                                            prompt:InputHoldEnd()
                                            if _G.AutoGeneral == false then
                                                gen.Remotes.RE:FireServer()
                                            end
                                        end)
                                        task.wait(0.75) -- t·ªëc ƒë·ªô m·ªü generator
                                        counter += 1
                                        if counter >= 10 or not isInGame then break end
                                    end
                                    busy = false
                                    if not isInGame then break end
                                end
                            end
                        end
                    end
                end
            end
            task.wait(0.5)
        end
    end)
end)



    Tabs.Farm:AddSection("‚Ü≥ Generator")

local solveGeneratorCooldown = false
local AutoFinishGen = false

-- H√†m t√¨m generator g·∫ßn nh·∫•t
local function getClosestGenerator()
    local char = game.Players.LocalPlayer.Character
    if not char or not char.PrimaryPart then return nil end

    local root = char.PrimaryPart
    local closest, shortestDist = nil, math.huge

    local mapContainer = workspace:FindFirstChild("Map")
    if mapContainer then
        local ingame = mapContainer:FindFirstChild("Ingame")
        if ingame then
            local map = ingame:FindFirstChild("Map")
            if map then
                for _, obj in ipairs(map:GetChildren()) do
                    if obj.Name == "Generator" and obj:IsA("Model") and obj.PrimaryPart then
                        local dist = (root.Position - obj.PrimaryPart.Position).Magnitude
                        if dist < shortestDist then
                            closest = obj
                            shortestDist = dist
                        end
                    end
                end
            end
        end
    end
    return closest
end

-- N√∫t Finish generator th·ªß c√¥ng
Tabs.Farm:AddButton({
    Title = "Finish Generator",
    Callback = function()
        if solveGeneratorCooldown then 
            print("‚è≥ Please wait before trying again!") 
            return
        end
        if AutoFinishGen then
            print("‚ùå Please disable Auto Finish Generator first!")
            return
        end

        local gen = getClosestGenerator()
        if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
            gen.Remotes.RE:FireServer()
            solveGeneratorCooldown = true
            task.delay(1.5, function()
                solveGeneratorCooldown = false
            end)
        end
    end
})

-- Toggle Auto Finish Generator
Tabs.Farm:AddToggle("AutoFinishGen", {
    Title = "Auto Finish Generator",
    Default = false
}):OnChanged(function(state)
    AutoFinishGen = state

    if state then
        if solveGeneratorCooldown then
            print("‚ö†Ô∏è Please wait cooldown before enabling Auto Finish!") 
            -- t·∫Øt toggle qua Fluent.Options
            Fluent.Options.AutoFinishGen:SetValue(false)
            return
        end

        task.spawn(function()
            while AutoFinishGen do
                local gen = getClosestGenerator()
                if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
                    gen.Remotes.RE:FireServer()
                end
                solveGeneratorCooldown = true
                task.wait(1.5)
                solveGeneratorCooldown = false
            end
        end)
    else
        solveGeneratorCooldown = false
    end
end)


do
local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LP = Players.LocalPlayer

-- üîπ Cancel token cho pathfinding
local h = 0
_G.PlayerControlled = false

-- =========================
--  DANH S√ÅCH SURVIVORS H·ª¢P L·ªÜ
-- =========================
local AllowedSurvivors = {
    ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
    ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
    ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true,
}

local function isSurvivorValid()
    local char = LP.Character
    if not char then return false end
    return AllowedSurvivors[char.Name] == true
end

-- =========================
--  PH√ÅT HI·ªÜN NG∆Ø·ªúI CH∆†I ƒêI·ªÄU KHI·ªÇN
-- =========================
local moveKeys = {
    [Enum.KeyCode.W] = true, [Enum.KeyCode.A] = true, [Enum.KeyCode.S] = true, [Enum.KeyCode.D] = true,
    [Enum.KeyCode.Up] = true, [Enum.KeyCode.Left] = true, [Enum.KeyCode.Down] = true, [Enum.KeyCode.Right] = true,
}
local activeInputs, lastMoveTick = 0, 0
local IDLE_GRACE = 0.25

local function setControlled(flag)
    if _G.PlayerControlled ~= flag then
        _G.PlayerControlled = flag
        if flag then h = h + 1 end -- h·ªßy path ngay khi ng∆∞·ªùi ch∆°i can thi·ªáp
    end
end

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and moveKeys[input.KeyCode] then
        activeInputs += 1; setControlled(true)
    elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
        activeInputs += 1; setControlled(true)
    elseif input.UserInputType == Enum.UserInputType.Touch then
        local cam = workspace.CurrentCamera
        if cam and input.Position.X < cam.ViewportSize.X * 0.5 then
            activeInputs += 1; setControlled(true)
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Keyboard and moveKeys[input.KeyCode] then
        activeInputs = math.max(0, activeInputs - 1)
    elseif input.UserInputType == Enum.UserInputType.Gamepad1 or input.UserInputType == Enum.UserInputType.Touch then
        activeInputs = math.max(0, activeInputs - 1)
    end
    if activeInputs == 0 then lastMoveTick = tick() end
end)

RunService.Heartbeat:Connect(function()
    local hum = LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    if hum.MoveDirection.Magnitude > 0 then
        lastMoveTick = tick(); setControlled(true)
    elseif activeInputs == 0 and (tick() - lastMoveTick) >= IDLE_GRACE then
        setControlled(false)
    end
end)

-- =========================
--  PATHFINDING
-- =========================
local function pathfindTo(targetPos)
    local hNow = h
    local char = LP.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")
    if not (hum and root) then return end

    local path = PathfindingService:CreatePath({
        AgentRadius = 2, AgentHeight = 5,
        AgentCanJump = false, AgentJumpHeight = 10, AgentMaxSlope = 45
    })

    local ok = pcall(function() path:ComputeAsync(root.Position, targetPos) end)
    if not ok or path.Status ~= Enum.PathStatus.Success then return end

    for _, wp in ipairs(path:GetWaypoints()) do
        if hNow ~= h or _G.PlayerControlled then return end
        if not (hum and root and root.Parent) then return end

        hum:MoveTo(wp.Position)
        repeat task.wait()
        until hNow ~= h or _G.PlayerControlled or not root.Parent
           or ((root.Position * Vector3.new(1,0,1) - wp.Position * Vector3.new(1,0,1)).Magnitude <= 2)

        if wp.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end
    end
end

-- =========================
--  H·ªñ TR·ª¢ KI·ªÇM TRA KILLER
-- =========================
local function isKillerNearGenerator(generatorPos, distance)
    local killersFolder = Workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return false end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        local hrp = killer:FindFirstChild("HumanoidRootPart")
        if hrp and (hrp.Position - generatorPos).Magnitude <= distance then
            return true
        end
    end
    return false
end

-- =========================
--  TOGGLE AUTO WALK & FIX GENERATORS
-- =========================
local GenWalkToggle = Tabs.Farm:AddToggle("GenWalkToggle", {
    Title = "Walk To Generator",
    Default = false
})

GenWalkToggle:OnChanged(function(Value)
    _G.AutoGenerators = Value
    if not Value then h = h + 1 end

    -- Auto Sprint (c√≥ ki·ªÉm so√°t stamina)
    if Value then
        _G.alwaysSprint = true
        task.spawn(function()
            local okSprint, sprint = pcall(function() return require(ReplicatedStorage.Systems.Character.Game.Sprinting) end)
            local okStam, stamina = pcall(function() return require(ReplicatedStorage.Systems.Character.Game.StaminaHandler) end)
            if not okSprint then return end

            local LOW, HIGH, lastReset, forceStop = 10, 80, tick(), false
            local function fireSprint(flag)
                sprint.IsSprinting = flag
                pcall(function() if sprint.__sprintedEvent then sprint.__sprintedEvent:Fire(flag) end end)
            end

            while _G.alwaysSprint and _G.AutoGenerators and task.wait() do
                -- üîí Ch·ªâ ch·∫°y khi l√† survivor h·ª£p l·ªá; n·∫øu kh√¥ng th√¨ t·∫Øt sprint v√† ch·ªù
                if not isSurvivorValid() then
                    if okSprint and sprint.IsSprinting then fireSprint(false) end
                    continue
                end

                if okStam and type(stamina.Value) == "number" then
                    if stamina.Value <= LOW then if sprint.IsSprinting then fireSprint(false) end; forceStop = true end
                    if forceStop and stamina.Value >= HIGH then fireSprint(true); forceStop = false; lastReset = tick() end
                end
                if not forceStop and not sprint.IsSprinting then fireSprint(true); lastReset = tick() end
                if not forceStop and tick() - lastReset >= 3 then
                    fireSprint(false); task.wait(0.1); fireSprint(true); lastReset = tick()
                end
            end
        end)
    else
        _G.alwaysSprint = false
    end

    -- Auto Generators loop
    task.spawn(function()
        while true do
            if not _G.AutoGenerators then task.wait(1); continue end
            if not isSurvivorValid() then task.wait(1); continue end -- ‚úÖ ch·ªâ cho ph√©p survivors h·ª£p l·ªá

            if _G.PlayerControlled then task.wait(0.1); continue end

            local hrp = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then task.wait(1); continue end

            local map = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Ingame") and Workspace.Map.Ingame:FindFirstChild("Map")
            if not map then task.wait(2); continue end

            local gens = {}
            for _, gen in ipairs(map:GetChildren()) do
                if gen.Name == "Generator" and gen:FindFirstChild("Progress") and gen.Progress.Value < 100 then
                    table.insert(gens, gen)
                end
            end
            if #gens == 0 then task.wait(3); continue end

            table.sort(gens, function(a, b)
                local ca, cb = a.Positions and a.Positions:FindFirstChild("Center"), b.Positions and b.Positions:FindFirstChild("Center") -- ‚úÖ s·ª≠a 'v√†' -> 'and'
                if ca and cb then
                    return (hrp.Position - ca.Position).Magnitude < (hrp.Position - cb.Position).Magnitude
                end
                return false
            end)

            local targetGen = gens[1]
            if targetGen and targetGen.Positions and targetGen.Positions:FindFirstChild("Center") then
                local center = targetGen.Positions.Center.Position
                if isKillerNearGenerator(center, 50) then task.wait(2); continue end

                if not _G.PlayerControlled then pcall(function() pathfindTo(center) end) end
                repeat task.wait(0.05)
                until not _G.AutoGenerators or _G.PlayerControlled or not hrp.Parent or (hrp.Position - center).Magnitude <= 6
                if _G.PlayerControlled then continue end

                local prompt = targetGen.Main and targetGen.Main:FindFirstChild("Prompt")
                if prompt and (hrp.Position - center).Magnitude <= 6 then
                    prompt.HoldDuration, prompt.RequiresLineOfSight, prompt.MaxActivationDistance = 0, false, 99999
                    while _G.AutoGenerators and not _G.PlayerControlled and targetGen.Parent and targetGen:FindFirstChild("Progress") and targetGen.Progress.Value < 100 do
                        if (hrp.Position - center).Magnitude > 6 then break end
                        -- üîπ Nh·∫•n 1 l·∫ßn r·ªìi ch·ªù 3 gi√¢y
                        pcall(function()
                            prompt:InputHoldBegin()
                        end)
                        task.wait(0.2) -- gi·ªØ nh·∫π ƒë·ªÉ ch·∫Øc ch·∫Øn ƒÉn l·ªánh
                        pcall(function()
                            prompt:InputHoldEnd()
                        end)
                        task.wait(3.0) -- ngh·ªâ 3 gi√¢y
                    end
                end
            end
            task.wait(0.5)
        end
    end)
end)

-- Reset path khi map m·ªõi spawn
Workspace.ChildAdded:Connect(function(child)
    if child.Name == "Map" then h = h + 1 end
end)
end

    Tabs.Farm:AddSection("‚Ü≥ Killers")


do
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local Active = false
    local loopRunning = false
    local CurrentTarget = nil
    local lastAttack = 0

    -- üü¢ Danh s√°ch ∆∞u ti√™n
    local PriorityList = {
        ["0206octavio"] = true
    }

    local function GetPriorityTarget()
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            -- ch·ªâ check model survivors
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
                if PriorityList[survivor.Name] then
                    local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        return survivor
                    end
                end
            end
        end
        return nil
    end

    local function GetClosestSurvivor()
        -- üî¥ Check ∆∞u ti√™n trong Survivors tr∆∞·ªõc
        local priorityTarget = GetPriorityTarget()
        if priorityTarget then
            return priorityTarget
        end

        -- üîµ N·∫øu kh√¥ng c√≥ trong danh s√°ch ∆∞u ti√™n ‚Üí ch·ªçn g·∫ßn nh·∫•t
        local localChar = LocalPlayer.Character
        if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return nil end
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        local closest, minDist = nil, math.huge
        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            local humanoid = survivor:FindFirstChildOfClass("Humanoid")
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
                local dist = (localChar.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    closest = survivor
                end
            end
        end
        return closest
    end

    local function KillTarget(target)
        pcall(function()
            if not target then return end
            local localChar = LocalPlayer.Character
            if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return end

            -- D·ªãch chuy·ªÉn t·ªõi m·ª•c ti√™u
            localChar.HumanoidRootPart.CFrame = target.HumanoidRootPart.CFrame

            -- Ch·ªâ ƒë√°nh n·∫øu ƒë√£ qua 0.5 gi√¢y t·ª´ l·∫ßn ƒë√°nh tr∆∞·ªõc
            if tick() - lastAttack >= 0.5 then
                lastAttack = tick()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local remote = ReplicatedStorage:FindFirstChild("Modules")
                              and ReplicatedStorage.Modules:FindFirstChild("Network")
                              and ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")
                if remote and typeof(remote.FireServer) == "function" then
                    remote:FireServer("UseActorAbility", "Slash")
                    task.wait(0.05)
                    remote:FireServer("UseActorAbility", "Stab")
                    task.wait(0.05)
                    remote:FireServer("UseActorAbility", "Punch")
                end
            end
        end)
    end

    local function StartLoop()
        if loopRunning then return end
        loopRunning = true
        task.spawn(function()
            while Active do
                if not CurrentTarget 
                   or not CurrentTarget.Parent 
                   or not CurrentTarget:FindFirstChildOfClass("Humanoid") 
                   or CurrentTarget:FindFirstChildOfClass("Humanoid").Health <= 0 then
                    CurrentTarget = GetClosestSurvivor()
                end
                if CurrentTarget then
                    KillTarget(CurrentTarget)
                end
                task.wait(0.01)
            end
            loopRunning = false
        end)
    end

    Tabs.Farm:AddToggle("AutoKillSurvivors", {
        Title = "Auto Kill Survivors",
        Default = false,
        Callback = function(Value)
            Active = Value
            if Active then
                StartLoop()
            end
        end
    })
end



do
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local h = 0 -- cancel token
local lastAttack = 0 -- cooldown
local AutoFarmRunning = false -- tr·∫°ng th√°i toggle

-- üîπ Danh s√°ch Killers
local KillersList = {
    ["Slasher"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true,
}

-- üîπ H√†m d√πng skill
local function UseSkills()
    local success, err = pcall(function()
        local remote = ReplicatedStorage:FindFirstChild("Modules")
                    and ReplicatedStorage.Modules:FindFirstChild("Network")
                    and ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")

        if remote and typeof(remote.FireServer) == "function" then
            remote:FireServer("UseActorAbility", "Slash")
            task.wait(0.05)
            remote:FireServer("UseActorAbility", "Stab")
            task.wait(0.05)
            remote:FireServer("UseActorAbility", "Punch")
        end
    end)
    if not success then warn("UseSkills error:", err) end
end

-- üîπ Pathfinding t·ªõi v·ªã tr√≠
local function pathfindTo(targetPos)
    local hNow = h
    local plr = Players.LocalPlayer
    local char = plr and plr.Character
    if not char or not AutoFarmRunning then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")
    if not (hum and root) then return end

    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = false,
        AgentJumpHeight = 10,
        AgentMaxSlope = 45
    })

    local ok = pcall(function()
        path:ComputeAsync(root.Position, targetPos)
    end)
    if not ok or path.Status ~= Enum.PathStatus.Success then return end

    for _, waypoint in ipairs(path:GetWaypoints()) do
        if hNow ~= h or not AutoFarmRunning then return end
        if not (hum and root and root.Parent) then return end

        hum:MoveTo(waypoint.Position)
        repeat task.wait()
        until hNow ~= h
           or not AutoFarmRunning
           or not root.Parent
           or ((root.Position * Vector3.new(1,0,1) - waypoint.Position * Vector3.new(1,0,1)).Magnitude <= 2)

        if waypoint.Action == Enum.PathWaypointAction.Jump then
            hum.Jump = true
        end
    end
end

-- üîπ t√¨m survivor g·∫ßn nh·∫•t
local function getClosestSurvivor()
    local plr = Players.LocalPlayer
    local hrp = plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    if not (workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")) then return nil end

    local closest, dist = nil, math.huge
    for _, s in pairs(workspace.Players.Survivors:GetChildren()) do
        local hrp2 = s:FindFirstChild("HumanoidRootPart")
        local hum = s:FindFirstChildOfClass("Humanoid")
        if hrp2 and hum and hum.Health > 0 then
            local d = (hrp.Position - hrp2.Position).Magnitude
            if d < dist then
                closest, dist = s, d
            end
        end
    end
    return closest, dist
end

-- ‚úÖ Toggle Auto Farm
Tabs.Farm:AddToggle("AutoFollowSurvivor", {
    Title = "Auto Kill Survivors V2",
    Default = false,
}):OnChanged(function(enabled)
    AutoFarmRunning = enabled
    if enabled then
        task.spawn(function()
            while AutoFarmRunning do
                local ok, err = pcall(function()
                    local plr = Players.LocalPlayer
                    local char = plr and plr.Character

                    -- üîí ch·ªâ ch·∫°y n·∫øu m√¨nh l√† Killer
                    if not (char and KillersList[char.Name]) then
                        task.wait(1)
                        return
                    end

                    local target, dist = getClosestSurvivor()
                    if target then
                        local hrp = target:FindFirstChild("HumanoidRootPart")
                        local hum = target:FindFirstChildOfClass("Humanoid")
                        while AutoFarmRunning
                            and char and KillersList[char.Name]
                            and target.Parent
                            and hrp and hrp.Parent
                            and hum and hum.Health > 0 do
                            
                            pathfindTo(hrp.Position)

                            -- N·∫øu trong 6m th√¨ d√πng skill
                            local localHrp = char:FindFirstChild("HumanoidRootPart")
                            if localHrp and (localHrp.Position - hrp.Position).Magnitude <= 6 then
                                if tick() - lastAttack >= 0.5 then
                                    lastAttack = tick()
                                    UseSkills()
                                end
                            end
                            task.wait(0.01)
                        end
                    else
                        task.wait(0) -- ngh·ªâ nh·∫π khi kh√¥ng c√≥ survivor
                    end
                end)

                if not ok then
                    warn("AutoFarm error:", err)
                    task.wait(1) -- ch·ªù 1s r·ªìi ch·∫°y l·∫°i ƒë·ªÉ tr√°nh crash
                end
            end
        end)
    else
        -- t·∫Øt ‚Üí tƒÉng token ƒë·ªÉ h·ªßy path hi·ªán t·∫°i
        h = h + 1
    end
end)
end


    Tabs.Farm:AddSection("‚Ü≥ Items")

local Players = game:GetService("Players")
local LP = Players.LocalPlayer

-- H√†m nh·∫∑t item g·∫ßn nh·∫•t
local function pickUpNearest()
    local map = workspace:FindFirstChild("Map") 
                and workspace.Map:FindFirstChild("Ingame") 
                and workspace.Map.Ingame:FindFirstChild("Map")
    if not map or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then return end

    local oldCFrame = LP.Character.HumanoidRootPart.CFrame
    for _, item in ipairs(map:GetChildren()) do
        if item:IsA("Tool") and item:FindFirstChild("ItemRoot") 
           and item.ItemRoot:FindFirstChild("ProximityPrompt") then
            LP.Character.HumanoidRootPart.CFrame = item.ItemRoot.CFrame
            task.wait(0.3)
            fireproximityprompt(item.ItemRoot.ProximityPrompt)
            task.wait(0.4)
            LP.Character.HumanoidRootPart.CFrame = oldCFrame
            break
        end
    end
end

-- Button: Pick Up Item (1 l·∫ßn)
Tabs.Farm:AddButton({
    Title = "Pick Up Item",
    Callback = pickUpNearest
})

-- Toggle: Auto PickUp Item (l·∫∑p)
Tabs.Farm:AddToggle("ItemPick", {
    Title = "Auto PickUp Item",
    Default = false
}):OnChanged(function(Value)
    _G.PickupItem = Value
    if not Value then return end

    task.spawn(function()
        while _G.PickupItem do
            pickUpNearest()
            task.wait(0.2) -- delay gi·ªØa m·ªói l·∫ßn nh·∫∑t
        end
    end)
end)




-- Tabs.Main

Tabs.Main:AddParagraph({
    Title = "How to Use Script :",
    Content = "1: Must adjust the slider to increase or decrease\n2: Must not be min or max because it will not work\n3: Then turn on the buttons to use those functions\n\n|| Like, Share And Subscribe For SLK gaming ||"
})




    Tabs.Main:AddSection("‚Ü≥ Shedletsky")


do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local enabled = false
    local cooldown = false
    local lastTarget = nil
    local maxDistance = 5

    local killerNames = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
    local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

    -- Slash button + remote
    local slashButton, slashRemote, slashConnections = nil, nil, {}

    local function findSlashRemote()
        if slashRemote then return slashRemote end
        if not slashButton then return nil end
        for _, conn in ipairs(getconnections(slashButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                for _, v in pairs(getupvalues(f)) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        slashRemote = v
                        warn("[AutoSlash] Found Slash Remote:", v:GetFullName())
                        return slashRemote
                    end
                end
            end
        end
        return nil
    end

    local function initSlashButton()
        local gui = lp:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        slashButton = container and container:FindFirstChild("Slash")
        if slashButton and slashButton:IsA("ImageButton") then
            slashConnections = getconnections(slashButton.MouseButton1Click)
            findSlashRemote()
        end
    end

    initSlashButton()
    lp.CharacterAdded:Connect(function()
        task.wait(0.5)
        initSlashButton()
    end)

    local function useSlash()
        if slashRemote then
            pcall(function()
                slashRemote:FireServer(true)
                task.delay(0.05, function()
                    slashRemote:FireServer(false)
                end)
            end)
        elseif slashButton then
            for _, conn in ipairs(slashConnections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() slashButton:Activate() end)
        end
    end

    -- Toggle
    local SlashToggle = Tabs.Main:AddToggle("SlashToggle", {
        Title = "Auto Slash",
        Default = false
    })
    SlashToggle:OnChanged(function(Value) enabled = Value end)

    -- Slider
    local DistanceSlider = Tabs.Main:AddSlider("DistanceSlider", {
        Title = "Distance",
        Min = 1, Max = 50, Default = 5,
        Rounding = 1, ValueName = "studs"
    })
    DistanceSlider:OnChanged(function(Value) maxDistance = Value end)

    -- Helper
    local function isBehindTarget(hrp, targetHRP)
        local direction = targetHRP.CFrame.LookVector
        local toPlayer = (hrp.Position - targetHRP.Position)
        local distance = toPlayer.Magnitude
        local isBehind = toPlayer:Dot(direction) < -0.5
        return distance <= maxDistance and isBehind
    end

    -- Main loop
    RunService.Heartbeat:Connect(function()
        if not enabled or cooldown then return end

        local char = lp.Character
        if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
        local hrp = char.HumanoidRootPart

        for _, name in ipairs(killerNames) do
            local killer = killersFolder:FindFirstChild(name)
            if killer and killer:FindFirstChild("HumanoidRootPart") then
                local kHRP = killer.HumanoidRootPart

                if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
                    cooldown = true
                    lastTarget = killer

                    -- Teleport ra sau l∆∞ng
                    local backPos = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                    hrp.CFrame = CFrame.new(backPos, kHRP.Position)

                    -- Gi·ªØ v·ªã tr√≠ + spam Slash 1 gi√¢y
                    local start = tick()
                    local connection
                    connection = RunService.Heartbeat:Connect(function()
                        if not (char and char.Parent and kHRP and kHRP.Parent) then
                            if connection then connection:Disconnect() end
                            return
                        end
                        if tick() - start >= 1 then
                            if connection then connection:Disconnect() end
                            task.delay(2, function()
                                cooldown = false
                                lastTarget = nil
                            end)
                            return
                        end

                        local back = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                        hrp.CFrame = CFrame.new(back, kHRP.Position)

                        -- G·ªçi skill Slash qua UI Remote
                        useSlash()
                    end)

                    break
                end
            end
        end
    end)
end



do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local healEnabled = false
    local healHPThreshold = 50
    local healDistance = 50

    -- Heal button + remote
    local healButton, healRemote, healConnections = nil, nil, {}

    -- t√¨m RemoteEvent t·ª´ button Heal
    local function findHealRemote()
        if healRemote then return healRemote end
        if not healButton then return nil end
        for _, conn in ipairs(getconnections(healButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                local upvals = getupvalues(f)
                for _, v in pairs(upvals) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        healRemote = v
                        warn("[AutoHeal] Found Heal Remote:", v:GetFullName())
                        return healRemote
                    end
                end
            end
        end
        return nil
    end

    local function initHealButton()
        local gui = lp:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        healButton = container and container:FindFirstChild("FriedChicken")
        if healButton and healButton:IsA("ImageButton") then
            healConnections = getconnections(healButton.MouseButton1Click)
            findHealRemote()
        end
    end

    initHealButton()
    lp.CharacterAdded:Connect(function()
        task.wait(0.5)
        initHealButton()
    end)

    local function useHeal()
        if healRemote then
            pcall(function()
                healRemote:FireServer(true)
                task.delay(0.05, function()
                    healRemote:FireServer(false)
                end)
            end)
        elseif healButton then
            for _, conn in ipairs(healConnections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() healButton:Activate() end)
        end
    end

    -- UI ------------------------------------------------
    local HealToggle = Tabs.Main:AddToggle("HealToggle", {
        Title = "Auto Heal",
        Default = false
    })
    HealToggle:OnChanged(function(v) healEnabled = v end)

    local HealHPSlider = Tabs.Main:AddSlider("HealHPSlider", {
        Title = "Heal HP",
        Min = 1, Max = 100, Default = 50,
        Rounding = 0, ValueName = "HP"
    })
    HealHPSlider:OnChanged(function(v) healHPThreshold = v end)

    local HealDistanceSlider = Tabs.Main:AddSlider("HealDistanceSlider", {
        Title = "Distance",
        Min = 1, Max = 150, Default = 50,
        Rounding = 0, ValueName = "studs"
    })
    HealDistanceSlider:OnChanged(function(v) healDistance = v end)

    -- Helpers -------------------------------------------------------------
    local function getPlayersFolders()
        local pf = workspace:FindFirstChild("Players")
        if not pf then return nil, nil, nil end
        return pf, pf:FindFirstChild("Killers"), pf:FindFirstChild("Survivors")
    end

    local function belongsToMe(m)
        if not (m and m:IsA("Model")) then return false end
        if m:GetAttribute("Username") == lp.Name then return true end
        local UsernameSV = m:FindFirstChild("Username")
        if UsernameSV and typeof(UsernameSV.Value) == "string" and UsernameSV.Value == lp.Name then return true end
        local Owner = m:FindFirstChild("Owner") or m:FindFirstChild("Player")
        if Owner and Owner.Value == lp then return true end
        local uidAttr = m:GetAttribute("UserId")
        if uidAttr and tonumber(uidAttr) == lp.UserId then return true end
        if m.Name == lp.Name then return true end
        return false
    end

    local function getMyShedletsky()
        local pf, killersFolder, survivorsFolder = getPlayersFolders()
        local candidates = {}

        local function scan(container)
            if not container then return end
            for _, d in ipairs(container:GetDescendants()) do
                if d:IsA("Model") and d.Name == "Shedletsky" and d:FindFirstChild("Humanoid") and d:FindFirstChild("HumanoidRootPart") then
                    if belongsToMe(d) then table.insert(candidates, d) end
                end
            end
        end

        scan(killersFolder)
        scan(survivorsFolder)
        scan(workspace)

        if #candidates == 0 then return nil, nil, nil end

        local basePos
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            basePos = lp.Character.HumanoidRootPart.Position
        end

        local best, bestDist = candidates[1], math.huge
        if basePos then
            for _, m in ipairs(candidates) do
                local hrp = m:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local d = (hrp.Position - basePos).Magnitude
                    if d < bestDist then best, bestDist = m, d end
                end
            end
        end

        local hum = best:FindFirstChildOfClass("Humanoid")
        local hrp = best:FindFirstChild("HumanoidRootPart")
        return best, hum, hrp
    end

    local function getNearestKillerDist(fromHRP, myModel)
        local _, killersFolder = getPlayersFolders()
        if not (killersFolder and fromHRP) then return math.huge end
        local nearest = math.huge
        for _, k in ipairs(killersFolder:GetChildren()) do
            if k ~= myModel then
                local khrp = k:FindFirstChild("HumanoidRootPart")
                if khrp then
                    local d = (fromHRP.Position - khrp.Position).Magnitude
                    if d < nearest then nearest = d end
                end
            end
        end
        return nearest
    end

    -- Main loop ----------------------------------------------------------
    RunService.Heartbeat:Connect(function()
        if not healEnabled then return end

        local myModel, myHumanoid, myHRP = getMyShedletsky()
        if not (myModel and myHumanoid and myHRP) then return end
        if myHumanoid.Health <= 0 then return end

        local nearestDist = getNearestKillerDist(myHRP, myModel)

        if myHumanoid.Health <= healHPThreshold and nearestDist >= healDistance then
            useHeal()
        end
    end)
end



    Tabs.Main:AddSection("‚Ü≥ Chance")


do
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local active = false
local useOffset = true
local predictionMode = "Speed"
local aimMode = "Normal"
local aimDuration = 1.7
local fasterDuration = 1.5
local spinDuration = 0.5
local aimTargets = {"Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli"}

local Humanoid, HRP = nil, nil
local originalWS, originalJP, originalAutoRotate = nil, nil, nil
local aiming = false
local prevFlintVisibleAim = false
local lastTriggerTime = 0

local autoCoinflip = false
local coinflipTargetCharge = 3
local coinflipCooldown = 0.15
local lastCoinflipTime = 0

local coinflipButton, coinflipRemote, coinflipConnections = nil, nil, {}

local function findCoinflipRemote()
    if coinflipRemote then return coinflipRemote end
    if not coinflipButton then return nil end
    for _, conn in ipairs(getconnections(coinflipButton.MouseButton1Click)) do
        local f = conn.Function
        if f and islclosure(f) then
            for _, v in pairs(getupvalues(f)) do
                if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                    coinflipRemote = v
                    return coinflipRemote
                end
            end
        end
    end
    return nil
end

local function initCoinflipButton()
    local gui = LocalPlayer:FindFirstChild("PlayerGui")
    if not gui then return end
    local mainUI = gui:FindFirstChild("MainUI")
    local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
    coinflipButton = container and container:FindFirstChild("Reroll")
    if coinflipButton and coinflipButton:IsA("ImageButton") then
        coinflipConnections = getconnections(coinflipButton.MouseButton1Click)
        findCoinflipRemote()
    end
end

initCoinflipButton()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    initCoinflipButton()
end)

local function useCoinflip()
    if coinflipRemote then
        pcall(function()
            coinflipRemote:FireServer(true)
            task.delay(0.05, function()
                coinflipRemote:FireServer(false)
            end)
        end)
    elseif coinflipButton then
        for _, conn in ipairs(coinflipConnections) do
            pcall(function() conn:Fire() end)
        end
        pcall(function() coinflipButton:Activate() end)
    end
end

Tabs.Main:AddDropdown("AimMode", {
    Title = "Aim Mode",
    Values = {"Normal", "Faster", "Reflex"},
    Default = "Normal",
    Callback = function(val) aimMode = val end
})

Tabs.Main:AddDropdown("PredictionMode", {
    Title = "Prediction Mode",
    Values = {"Speed", "Ping", "front", "No Lag"},
    Default = "Speed",
    Callback = function(val) predictionMode = val end
})

Tabs.Main:AddDropdown("CoinflipChargeDropdown", {
    Title = "Select Score",
    Values = {"1 Point", "2 Point", "3 Point"},
    Default = "3 Point",
}):OnChanged(function(val)
    local num = tonumber(val and val:match("%d+"))
    if num then
        coinflipTargetCharge = num
    end
end)

Tabs.Main:AddToggle("OffsetToggle", {
    Title = "Enable Offset",
    Default = true,
    Callback = function(state) useOffset = state end
})

Tabs.Main:AddToggle("AimbotToggle", {
    Title = "Auto Aim Shoot",
    Default = false,
    Callback = function(state) active = state end
})

Tabs.Main:AddToggle("AutoCoinflipToggle", {
    Title = "Auto Coin Flip",
    Default = false,
}):OnChanged(function(state)
    autoCoinflip = state
end)

local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end
if LocalPlayer.Character then setupCharacter(LocalPlayer.Character) end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

local function getValidTarget()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, name in ipairs(aimTargets) do
            local target = killersFolder:FindFirstChild(name)
            if target and target:FindFirstChild("HumanoidRootPart") then
                return target.HumanoidRootPart
            end
        end
    end
    return nil
end

local function getPingSeconds()
    local pingStat = Stats.Network.ServerStatsItem["Data Ping"]
    if pingStat then return pingStat:GetValue() / 1000 end
    return 0.1
end

local function isFlintlockVisible()
    if not LocalPlayer.Character then return false end
    local flint = LocalPlayer.Character:FindFirstChild("Flintlock", true)
    if not flint then return false end
    if not (flint:IsA("BasePart") or flint:IsA("MeshPart") or flint:IsA("UnionOperation")) then
        flint = flint:FindFirstChildWhichIsA("BasePart", true)
        if not flint then return false end
    end
    return flint.Transparency < 1
end

local movementThreshold = 0.5
local function getPredictedAimPosPing(targetHRP)
    local ping = getPingSeconds()
    local velocity = targetHRP.Velocity
    if velocity.Magnitude <= movementThreshold then return targetHRP.Position end
    return targetHRP.Position + (velocity * ping)
end

local function getPredictedAimPosInfrontHRPPing(targetHRP)
    local ping = getPingSeconds()
    local studs = ping * 60
    if targetHRP.Velocity.Magnitude <= movementThreshold then return targetHRP.Position end
    return targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
end

local function computeAimPos(targetHRP)
    if predictionMode == "Ping" then
        return getPredictedAimPosPing(targetHRP)
    elseif predictionMode == "front" then
        return targetHRP.Position + targetHRP.CFrame.LookVector * 4
    elseif predictionMode == "No Lag" then
        return getPredictedAimPosInfrontHRPPing(targetHRP)
    else
        local velocity = targetHRP.Velocity
        if velocity.Magnitude > 0.1 then
            if useOffset then
                local toTarget = (targetHRP.Position - HRP.Position).Unit
                local moveDir = velocity.Unit
                local dot = toTarget:Dot(moveDir)
                if math.abs(dot) < 0.85 then
                    return targetHRP.Position + velocity * (4 / 60)
                else
                    return targetHRP.Position
                end
            else
                return targetHRP.Position
            end
        else
            return targetHRP.Position
        end
    end
end

local function faceInstant(toPos)
    if not HRP or not toPos then return end
    local fromPos = HRP.Position
    local lookAt = Vector3.new(toPos.X, fromPos.Y, toPos.Z)
    local targetCF = CFrame.new(fromPos, lookAt)
    HRP.CFrame = HRP.CFrame:Lerp(targetCF, 0.99)
end

local function readCoinflipChargesText()
    local ok, txt = pcall(function()
        local mainUI = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
        if not mainUI then return nil end
        local abil = mainUI:FindFirstChild("AbilityContainer")
        if not abil then return nil end
        local coin = abil:FindFirstChild("Reroll")
        if not coin then return nil end
        local chargesLabel = coin:FindFirstChild("Charges")
        if not chargesLabel then return nil end
        return tonumber(chargesLabel.Text)
    end)
    if ok then return txt end
    return nil
end

RunService.RenderStepped:Connect(function()
    if active and Humanoid and HRP then
        local isVisible = isFlintlockVisible()
        if isVisible and not prevFlintVisibleAim and not aiming then
            lastTriggerTime = tick()
            aiming = true
        end
        prevFlintVisibleAim = isVisible
        if aiming then
            local elapsed = tick() - lastTriggerTime
            if aimMode == "Reflex" then
                if elapsed <= spinDuration then
                    local spinProgress = elapsed / spinDuration
                    local spinAngle = math.rad(360 * spinProgress)
                    HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, spinAngle, 0)
                elseif elapsed <= spinDuration + 0.7 then
                    if not originalWS then
                        originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
                    end
                    Humanoid.AutoRotate = false
                    HRP.AssemblyAngularVelocity = Vector3.zero
                    local targetHRP = getValidTarget()
                    if targetHRP then
                        local aimPos = computeAimPos(targetHRP)
                        if targetHRP.Velocity.Magnitude > 0.1 then
                            local moveDir = targetHRP.Velocity.Unit
                            local lookAtPos = HRP.Position + Vector3.new(moveDir.X, 0, moveDir.Z)
                            HRP.CFrame = CFrame.new(HRP.Position, lookAtPos)
                        end
                        faceInstant(aimPos)
                    end
                else
                    aiming = false
                    if originalWS then
                        Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate = originalWS, originalJP, originalAutoRotate
                        originalWS, originalJP, originalAutoRotate = nil, nil, nil
                    end
                end
            elseif aimMode == "Normal" or aimMode == "Faster" then
                local duration = (aimMode == "Faster") and fasterDuration or aimDuration
                if elapsed <= duration then
                    if not originalWS then
                        originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
                    end
                    Humanoid.AutoRotate = false
                    HRP.AssemblyAngularVelocity = Vector3.zero
                    local targetHRP = getValidTarget()
                    if targetHRP then
                        local aimPos = computeAimPos(targetHRP)
                        if targetHRP.Velocity.Magnitude > 0.1 then
                            local moveDir = targetHRP.Velocity.Unit
                            local lookAtPos = HRP.Position + Vector3.new(moveDir.X, 0, moveDir.Z)
                            HRP.CFrame = CFrame.new(HRP.Position, lookAtPos)
                        end
                        faceInstant(aimPos)
                    end
                else
                    aiming = false
                    if originalWS then
                        Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate = originalWS, originalJP, originalAutoRotate
                        originalWS, originalJP, originalAutoRotate = nil, nil, nil
                    end
                end
            end
        end
    end
    if autoCoinflip then
        local charges = readCoinflipChargesText()
        if charges and charges < coinflipTargetCharge then
            local now = tick()
            if now - lastCoinflipTime >= coinflipCooldown then
                lastCoinflipTime = now
                useCoinflip()
            end
        end
    end
end)
end



    Tabs.Main:AddSection("‚Ü≥ Two Time")

do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local enabled = false
    local cooldown = false
    local lastTarget = nil
    local maxDistance = 5
    local killerNames = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
    local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

    -- UI skill button + remote
    local daggerButton, daggerRemote, daggerConnections = nil, nil, {}

    local function findDaggerRemote()
        if daggerRemote then return daggerRemote end
        if not daggerButton then return nil end
        for _, conn in ipairs(getconnections(daggerButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                local upvals = getupvalues(f)
                for _, v in pairs(upvals) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        daggerRemote = v
                        warn("[Backstab] Found Dagger Remote:", v:GetFullName())
                        return daggerRemote
                    end
                end
            end
        end
        return nil
    end

    local function initDaggerButton()
        local gui = lp:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        daggerButton = container and container:FindFirstChild("Dagger")
        if daggerButton and daggerButton:IsA("ImageButton") then
            daggerConnections = getconnections(daggerButton.MouseButton1Click)
            findDaggerRemote()
        end
    end

    initDaggerButton()
    lp.CharacterAdded:Connect(function()
        task.wait(0.5)
        initDaggerButton()
    end)

    local function useDagger()
        if daggerRemote then
            pcall(function()
                daggerRemote:FireServer(true)
                task.delay(0.05, function()
                    daggerRemote:FireServer(false)
                end)
            end)
        elseif daggerButton then
            for _, conn in ipairs(daggerConnections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() daggerButton:Activate() end)
        end
    end

    -- Toggle
    local BackstabToggle = Tabs.Main:AddToggle("BackstabToggle", {
        Title = "Auto Backstab",
        Default = false
    })
    BackstabToggle:OnChanged(function(Value)
        enabled = Value
    end)

    -- Slider
    local DistanceSlider = Tabs.Main:AddSlider("DistanceSlider", {
        Title = "Distance",
        Min = 1,
        Max = 50,
        Default = 5,
        Rounding = 1,
        ValueName = "studs"
    })
    DistanceSlider:OnChanged(function(Value)
        maxDistance = Value
    end)

    -- Helper
    local function isBehindTarget(hrp, targetHRP)
        local direction = -targetHRP.CFrame.LookVector
        local toPlayer = (hrp.Position - targetHRP.Position)
        local distance = toPlayer.Magnitude
        local isBehind = toPlayer:Dot(direction) > 0.5
        return distance <= maxDistance and isBehind
    end

    -- Main loop
    RunService.Heartbeat:Connect(function()
        if not enabled or cooldown then return end

        local char = lp.Character
        if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
        local hrp = char.HumanoidRootPart

        for _, name in ipairs(killerNames) do
            local killer = killersFolder:FindFirstChild(name)
            if killer and killer:FindFirstChild("HumanoidRootPart") then
                local kHRP = killer.HumanoidRootPart

                if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
                    cooldown = true
                    lastTarget = killer

                    -- Teleport ra sau l∆∞ng
                    local behindPos = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                    hrp.CFrame = CFrame.new(behindPos, behindPos + kHRP.CFrame.LookVector)

                    -- Gi·ªØ v·ªã tr√≠ v√† spam skill trong 0.7s
                    local start = tick()
                    local connection
                    connection = RunService.Heartbeat:Connect(function()
                        if not (char and char.Parent and kHRP and kHRP.Parent) then
                            if connection then connection:Disconnect() end
                            return
                        end
                        if tick() - start >= 0.7 then
                            if connection then connection:Disconnect() end
                            task.delay(2, function()
                                cooldown = false
                                lastTarget = nil
                            end)
                            return
                        end

                        -- Lu√¥n gi·ªØ sau l∆∞ng
                        local behind = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                        hrp.CFrame = CFrame.new(behind, behind + kHRP.CFrame.LookVector)

                        -- G·ªçi skill qua button/remote gi·ªëng block
                        useDagger()
                    end)

                    break
                end
            end
        end
    end)
end



    Tabs.Main:AddSection("‚Ü≥ 007n7")

do
    -- Invisible upon Cloning (sandboxed)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local running = false
    local animTrack

    local function getHumanoid()
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        return char:FindFirstChildOfClass("Humanoid"), char
    end

    local function getAnimator(humanoid)
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if not animator then
            animator = Instance.new("Animator")
            animator.Parent = humanoid
        end
        return animator
    end

    local function playInvisibleAnim(humanoid)
        local animator = getAnimator(humanoid)
        if not animTrack or not animTrack.IsPlaying then
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://75804462760596"
            animTrack = animator:LoadAnimation(animation)
            animTrack.Looped = true
            animTrack:Play()
            animTrack:AdjustSpeed(0)
        end
    end

    local function stopInvisibleAnim()
        if animTrack and animTrack.IsPlaying then
            animTrack:Stop()
            animTrack = nil
        end
    end

    local function handleToggle(enabled)
        local humanoid, char = getHumanoid()
        if not humanoid or not char then return end

        if enabled then
            running = true
            task.spawn(function()
                while running do
                    humanoid, char = getHumanoid()
                    if not humanoid or not char then break end

                    local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
                    local root = char:FindFirstChild("HumanoidRootPart")

                    if torso and torso.Transparency ~= 0 then
                        playInvisibleAnim(humanoid)
                        if root then root.Transparency = 0.4 end
                    else
                        stopInvisibleAnim()
                        if root then root.Transparency = 1 end
                    end

                    task.wait(0.5)
                end
            end)
        else
            running = false
            stopInvisibleAnim()
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.Transparency = 1
            end
        end
    end

    -- === Toggle g·ªëc: Invisible if cloned ===
    Tabs.Main:AddToggle("InvisibleClone", {
        Title = "Invisible if cloned",
        Default = false
    }):OnChanged(function(val)
        handleToggle(val)
    end)

    -- === Toggle m·ªõi: Invisible lu√¥n khi b·∫≠t ===
    Tabs.Main:AddToggle("InstantInvisible", {
        Title = "Invisible Immediately",
        Default = false
    }):OnChanged(function(val)
        -- Khi b·∫≠t, t√†ng h√¨nh ngay l·∫≠p t·ª©c
        local humanoid, char = getHumanoid()
        if not humanoid or not char then return end

        if val then
            playInvisibleAnim(humanoid)
            local root = char:FindFirstChild("HumanoidRootPart")
            if root then root.Transparency = 0.4 end
        else
            stopInvisibleAnim()
            local humanoid, char = getHumanoid()
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.Transparency = 1
            end
        end
    end)
end


    Tabs.Main:AddSection("‚Ü≥ Guest1337")


do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local localPlayer = Players.LocalPlayer

    local Killers = {
        ["Slasher"] = true,
        ["1x1x1x1"] = true,
        ["c00lkidd"] = true,
        ["Noli"] = true,
        ["JohnDoe"] = true,
        ["Quest666"] = true
    }

    local function isKiller(player)
        local char = player.Character
        if not char then return false end
        return Killers[char.Name] == true
    end

    local animationIds = {
        ["83829782357897"]  = true, -- Slash, 1x1x1x1
        ["126830014841198"] = true, -- Slash, Jason
        ["126355327951215"] = true, -- Behead, Jason
        ["121086746534252"] = true, -- GashingWoundStart, Jason
        ["105458270463374"] = true, -- Slash, JohnDoe
        ["18885909645"]     = true, -- Attack, c00lkid
        ["94162446513587"]  = true, -- Slash, JohnDoe, Skin: !Joner
        ["93069721274110"]  = true, -- Slash, JohnDoe, Skin: AnnihilationJohnDoe
        ["97433060861952"]  = true, -- Slash, JohnDoe, Skin: #SK
        ["121293883585738"] = true, -- Slash, 1x1x1x1
        ["92173139187970"]  = true, -- Slash, Skin: Hacklord1x1x1x1
        ["106847695270773"] = true, -- GashingWoundStart, Jason, Skin: Subject0Jason
        ["125403313786645"] = true, -- Slash, Jason, Skin: Subject0Jason
        ["81639435858902"]  = true, -- Behead, Jason, Skin: WhitePumpkinJason
        ["137314737492715"] = true, -- GashingWoundStart, Jason, Skin: WhitePumpkinJason
        ["120112897026015"] = true, -- Slash, Jason, Skin: WhitePumpkinJason
        ["82113744478546"]  = true, -- Behead, Jason (nhi·ªÅu skin)
        ["118298475669935"] = true, -- Slash, Jason (nhi·ªÅu skin)
        ["126681776859538"] = true, -- Behead, Jason, Skin: PursuerJason
        ["129976080405072"] = true, -- GashingWoundStart, Jason, Skin: PursuerJason
        ["109667959938617"] = true, -- Slash, Jason, Skin: PursuerJason
        ["74707328554358"]  = true, -- Slash, Jason, Skin: #DeadRabbitsJason
        ["133336594357903"] = true, -- Behead, Jason, Skin: #DeadRabbitsJason
        ["86204001129974"]  = true, -- GashingWoundStart, Jason, Skin: #DeadRabbitsJason
        ["70371667919898"]  = true, -- Attack, c00lkidd, Skin: MafiosoC00l
        ["131543461321709"] = true, -- Attack, c00lkidd, Skin: SaviorC00l
        ["106776364623742"] = true, -- Walkspeed Overing, c00lkidd (all skins)
        ["136323728355613"] = true, -- Swing, Noli
        ["109230267448394"] = true, -- Swing, Noli (all skins)
        ["139835501033932"] = true, -- VoidRush, Noli (all skins)
        ["114356208094580"] = true, -- VoidRush2, Noli
        ["106538427162796"] = true, -- Stab, All Noli
        ["126896426760253"] = true, -- VoidRush, Noli
        ["131430497821198"] = true, -- MassInfection, 1x1x1x1
        ["100592913030351"] = true, -- MassInfection, 1x1x1x1 (Fleskhjerta/AceOfSpades/Lancer)
        ["70447634862911"]  = true, -- MassInfection, Skin: Hacklord1x1x1x1
        ["97167027849946"]  = true,
        ["99135633258223"]  = true,
        ["98456918873918"]  = true,
        ["83251433279852"]  = true,
    }

    -- ch·ªâ c√°c id n√†y m·ªõi teleport
    local delayedAnimations = {
         ["74707328554358"]  = true,  -- Slash, Jason, Skin: #DeadRabbitsJason
        ["109667959938617"] = true, -- Slash, Jason, Skin: PursuerJason
        ["118298475669935"] = true, -- Slash, Jason (nhi·ªÅu skin)
        ["120112897026015"] = true, -- Slash, Jason, Skin: WhitePumpkinJason
        ["125403313786645"] = true, -- Slash, Jason, Skin: Subject0Jason
        ["126830014841198"] = true, -- Slash, Jason
    }

    local toggleOn = false
    local strictRangeOn = false
    local detectionRange = 18

    local blockRemote
    local blockButton, connections = nil, {}

    local function findBlockRemote()
        if blockRemote then return blockRemote end
        if not blockButton then return nil end
        for _, conn in ipairs(getconnections(blockButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                local upvals = getupvalues(f)
                for _, v in pairs(upvals) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        blockRemote = v
                        warn("[AutoBlock] Found Block Remote:", v:GetFullName())
                        return blockRemote
                    end
                end
            end
        end
        return nil
    end

    local function initBlockButton()
        local gui = localPlayer:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        blockButton = container and container:FindFirstChild("Block")
        if blockButton and blockButton:IsA("ImageButton") then
            connections = getconnections(blockButton.MouseButton1Click)
            findBlockRemote()
        end
    end

    initBlockButton()
    localPlayer.CharacterAdded:Connect(function()
        task.wait(0)
        initBlockButton()
    end)

    local function fastBlock()
        if blockRemote then
            pcall(function()
                blockRemote:FireServer(true)
                task.delay(1e-10, function()
                    blockRemote:FireServer(false)
                end)
            end)
        else
            if not blockButton or not blockButton.Visible then return end
            for _, conn in ipairs(connections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() blockButton:Activate() end)
        end
    end

    -- cooldown cho teleport
    local lastTeleport = 0

    local function teleportDodge(killerChar)
        local now = tick()
        if now - lastTeleport < 5 then return end -- delay 5s
        lastTeleport = now

        local myChar = localPlayer.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local killerRoot = killerChar and killerChar:FindFirstChild("HumanoidRootPart")
        if not (myRoot and killerRoot) then return end

        local oldCFrame = myRoot.CFrame
        local forward = killerRoot.CFrame.LookVector

        -- teleport ra tr∆∞·ªõc m·∫∑t Killer
        myRoot.CFrame = killerRoot.CFrame + forward * 7.5

        -- quay l·∫°i sau 0.1s
        task.delay(0.1, function()
            if myRoot then
                myRoot.CFrame = oldCFrame
            end
        end)
    end

    local function getBoolFlag(name, default)
        local flag = localPlayer:FindFirstChild(name)
        if not flag then
            flag = Instance.new("BoolValue")
            flag.Name = name
            flag.Value = default
            flag.Parent = localPlayer
        end
        return flag
    end

    local function getNumberFlag(name, default)
        local flag = localPlayer:FindFirstChild(name)
        if not flag then
            flag = Instance.new("NumberValue")
            flag.Name = name
            flag.Value = default
            flag.Parent = localPlayer
        end
        return flag
    end

    local toggleFlag = getBoolFlag("AutoBlockToggle", false)
    local strictFlag = getBoolFlag("AutoBlockStrictRange", false)
    local rangeFlag = getNumberFlag("AutoBlockRange", 18)

    toggleOn = toggleFlag.Value
    strictRangeOn = strictFlag.Value
    detectionRange = rangeFlag.Value

    Tabs.Main:AddToggle("AutoBlockV2", {
        Title = "Auto Block V2",
        Default = toggleOn,
    }):OnChanged(function(state)
        toggleOn = state
        toggleFlag.Value = state
    end)

    Tabs.Main:AddToggle("StrictRangeCheck", {
        Title = "Auto Check V2",
        Default = strictRangeOn,
    }):OnChanged(function(state)
        strictRangeOn = state
        strictFlag.Value = state
    end)

    Tabs.Main:AddInput("RangeCheckInput", {
        Title = "Range Check",
        Default = tostring(detectionRange),
        Placeholder = "Enter detection range"
    }):OnChanged(function(txt)
        local val = tonumber(txt)
        if val then
            detectionRange = val
            rangeFlag.Value = val
        end
    end)

    local playerConns = {}
    local recentBlocks = {}
    local COOLDOWN_ZERO, COOLDOWN_MISS = 0, 0

    local function cleanupPlayerConns(p)
        local tbl = playerConns[p]
        if tbl then
            for _, c in ipairs(tbl) do
                if c and c.Disconnect then c:Disconnect() end
            end
            playerConns[p] = nil
        end
        recentBlocks[p.UserId] = nil
    end

    local function shouldBlockNow(p, animId, track)
        recentBlocks[p.UserId] = recentBlocks[p.UserId] or {}
        local last = recentBlocks[p.UserId][animId] or 0
        local now = tick()
        if track.TimePosition <= 0 then
            if now - last >= COOLDOWN_ZERO then
                recentBlocks[p.UserId][animId] = now
                return true
            end
            return false
        else
            if now - last >= COOLDOWN_MISS then
                recentBlocks[p.UserId][animId] = now
                return true
            end
            return false
        end
    end

    local function onAnimationPlayed(player, char, track)
        if not toggleOn then return end
        if not (track and track.Animation) then return end
        local animIdStr = track.Animation.AnimationId
        local id = animIdStr and string.match(animIdStr, "%d+")
        if not id or not animationIds[id] then return end
        if strictRangeOn then
            local myChar = localPlayer.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            local root = char and char:FindFirstChild("HumanoidRootPart")
            if not myRoot or not root then return end
            local dist = (root.Position - myRoot.Position).Magnitude
            if dist > detectionRange then return end
        end
        if shouldBlockNow(player, id, track) then
            fastBlock()
            if isKiller(player) and delayedAnimations[id] then
                teleportDodge(char)
            end
        end
    end

    local function monitorCharacter(player, char)
        if not player or not char then return end
        local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 5)
        if not hum then return end
        local con = hum.AnimationPlayed:Connect(function(track)
            task.spawn(onAnimationPlayed, player, char, track)
        end)
        playerConns[player] = playerConns[player] or {}
        table.insert(playerConns[player], con)
    end

    local function onPlayerAdded(player)
        if player == localPlayer then return end
        if player.Character then monitorCharacter(player, player.Character) end
        local conCharAdded = player.CharacterAdded:Connect(function(char)
            task.wait(0)
            monitorCharacter(player, char)
        end)
        playerConns[player] = playerConns[player] or {}
        table.insert(playerConns[player], conCharAdded)
    end

    for _, p in ipairs(Players:GetPlayers()) do onPlayerAdded(p) end
    Players.PlayerAdded:Connect(onPlayerAdded)
    Players.PlayerRemoving:Connect(cleanupPlayerConns)

    local circles = {}

    local function createCircleFor(player, hrp)
        if circles[player] then circles[player]:Destroy() end
        local circle = Instance.new("Part")
        circle.Anchored, circle.CanCollide = true, false
        circle.Shape = Enum.PartType.Cylinder
        circle.Size = Vector3.new(0.2, detectionRange * 2, detectionRange * 2)
        circle.CFrame = hrp.CFrame * CFrame.Angles(0, 0, math.rad(90))
        circle.Material, circle.Transparency = Enum.Material.Neon, 0.5
        circle.Color = Color3.fromRGB(255, 0, 0)
        circle.Parent = workspace
        circles[player] = circle
    end

    local function removeCircle(player)
        if circles[player] then circles[player]:Destroy() circles[player] = nil end
    end

    RunService.Heartbeat:Connect(function()
        if not strictRangeOn then
            for _, circle in pairs(circles) do
                if circle then circle.Transparency = 1 end
            end
            return
        end
        local myChar = localPlayer.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= localPlayer then
                local char = player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                local hum = char and char:FindFirstChildOfClass("Humanoid")
                if hrp and hum and hum.Health > 0 and isKiller(player) then
                    if not circles[player] then createCircleFor(player, hrp) end
                    local circle = circles[player]
                    circle.Size = Vector3.new(0.2, detectionRange * 2, detectionRange * 2)
                    circle.CFrame = hrp.CFrame * CFrame.Angles(0, 0, math.rad(90))
                    local dist = (myRoot.Position - hrp.Position).Magnitude
                    circle.Color = (dist <= detectionRange) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                    circle.Transparency = 0.5
                else
                    removeCircle(player)
                end
            end
        end
    end)

    Players.PlayerRemoving:Connect(removeCircle)
end






do
    -- Auto Punch settings
    local autoPunchOn, aimPunch, flingPunchOn, customPunchEnabled = false, false, false, false
    local hiddenfling = false
    local flingPower = 10000
    local predictionValue = 4
    local customPunchAnimId = ""
    local Humanoid
    local lastPunchTime = 0
    local punchAnimIds = { "87259391926321" }
    local LP = game:GetService("Players").LocalPlayer
    local RunService = game:GetService("RunService")
    local PlayerGui = LP:WaitForChild("PlayerGui")

    -- Function: play custom punch anim
    local function playCustomPunch(animId)
        if not Humanoid then return end
        if not animId or animId == "" then return end
        local now = tick()
        if now - lastPunchTime < 1 then return end

        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            local animNum = tostring(track.Animation.AnimationId):match("%d+")
            if table.find(punchAnimIds, animNum) then
                track:Stop()
            end
        end

        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. animId
        local track = Humanoid:LoadAnimation(anim)
        track:Play()
        lastPunchTime = now
    end

    -- Hidden fling coroutine
    coroutine.wrap(function()
        local hrp, c, vel, movel = nil, nil, nil, 0.1
        while true do
            RunService.Heartbeat:Wait()
            if hiddenfling then
                while hiddenfling and not (c and c.Parent and hrp and hrp.Parent) do
                    RunService.Heartbeat:Wait()
                    c = LP.Character
                    hrp = c and c:FindFirstChild("HumanoidRootPart")
                end
                if hiddenfling then
                    vel = hrp.Velocity
                    hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
                    RunService.RenderStepped:Wait()
                    hrp.Velocity = vel
                    RunService.Stepped:Wait()
                    hrp.Velocity = vel + Vector3.new(0, movel, 0)
                    movel = movel * -1
                end
            end
        end
    end)()

    -- Auto Punch loop
    RunService.RenderStepped:Connect(function()
        local myChar = LP.Character
        if not myChar then return end
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        Humanoid = myChar:FindFirstChildOfClass("Humanoid")

        if autoPunchOn then
            local gui = PlayerGui:FindFirstChild("MainUI")
            local punchBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Punch")
            local charges = punchBtn and punchBtn:FindFirstChild("Charges")

            if charges and charges.Text == "1" then
                local killerNames = {"c00lkidd", "Slasher", "JohnDoe", "1x1x1x1", "Noli"}
                for _, name in ipairs(killerNames) do
                    local killer = workspace:FindFirstChild("Players")
                        and workspace.Players:FindFirstChild("Killers")
                        and workspace.Players.Killers:FindFirstChild(name)

                    if killer and killer:FindFirstChild("HumanoidRootPart") then
                        local root = killer.HumanoidRootPart
                        if root and myRoot and (root.Position - myRoot.Position).Magnitude <= 10 then
                            
                            -- Aim Punch
                            if aimPunch then
                                local humanoid = myChar:FindFirstChild("Humanoid")
                                if humanoid then humanoid.AutoRotate = false end
                                task.spawn(function()
                                    local start = tick()
                                    while tick() - start < 2 do
                                        if myRoot and root and root.Parent then
                                            local predictedPos = root.Position + (root.CFrame.LookVector * predictionValue)
                                            myRoot.CFrame = CFrame.lookAt(myRoot.Position, predictedPos)
                                        end
                                        task.wait()
                                    end
                                    if humanoid then humanoid.AutoRotate = true end
                                end)
                            end

                            -- Click punch button
                            for _, conn in ipairs(getconnections(punchBtn.MouseButton1Click)) do
                                pcall(function() conn:Fire() end)
                            end

                            -- Fling Punch
                            if flingPunchOn then
                                hiddenfling = true
                                task.spawn(function()
                                    local start = tick()
                                    while tick() - start < 1 do
                                        if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") and root and root.Parent then
                                            local frontPos = root.Position + (root.CFrame.LookVector * 2)
                                            LP.Character.HumanoidRootPart.CFrame = CFrame.new(frontPos, root.Position)
                                        end
                                        task.wait()
                                    end
                                    hiddenfling = false
                                end)
                            end

                            -- Custom anim
                            if customPunchEnabled and customPunchAnimId ~= "" then
                                playCustomPunch(customPunchAnimId)
                            end

                            break -- ch·ªâ ƒë√°nh 1 killer m·ªói v√≤ng
                        end
                    end
                end
            end
        end
    end)

    -- === N√∫t cho Tabs.Main (th√™m v√†o GUI c√≥ s·∫µn) ===
    Tabs.Main:AddToggle("AutoPunch", { Title = "Auto Punch", Default = false })
        :OnChanged(function(val) autoPunchOn = val end)

    Tabs.Main:AddToggle("AimPunch", { Title = "Punch Aimbot", Default = false })
        :OnChanged(function(val) aimPunch = val end)

    Tabs.Main:AddToggle("FlingPunch", { Title = "Fling Punch", Default = false })
        :OnChanged(function(val) flingPunchOn = val end)

    Tabs.Main:AddSlider("Prediction", {
        Title = "Aim Prediction",
        Min = 0, Max = 10, Default = 4, Rounding = 1,
    }):OnChanged(function(val) predictionValue = val end)

    Tabs.Main:AddSlider("FlingPower", {
        Title = "Fling Power",
        Min = 5000, Max = 500000, Default = 10000, Rounding = 0,
    }):OnChanged(function(val) flingPower = val end)

    Tabs.Main:AddInput("CustomAnim", {
        Title = "Custom Punch",
        Default = "",
        Placeholder = "Enter Animation ID"
    }):OnChanged(function(txt) customPunchAnimId = txt end)

    Tabs.Main:AddToggle("EnableCustomAnim", { Title = "Enable Custom Animation", Default = false })
        :OnChanged(function(val) customPunchEnabled = val end)
end




    Tabs.Main:AddSection("‚Ü≥ 1x1x1x1")

do
-- üß© GUI Toggle + Dropdown
local toggleOn = false
local toggleFlag = Instance.new("BoolValue")
toggleFlag.Name = "1x1x1x1AutoAim_ToggleFlag"
toggleFlag.Value = false

local aimMode = "One Player" -- default
local predictMovement = false -- toggle m·ªõi

Tabs.Main:AddDropdown("AimModeDropdown", {
    Title = "Aim Mode",
    Values = {"One Player", "Multi Players", "Teleport"},
    Default = "One Player",
}):OnChanged(function(value)
    aimMode = value
end)

Tabs.Main:AddToggle("AimSkill1x1x1x1", {
    Title = "MassInfection Aimbot",
    Default = toggleOn,
}):OnChanged(function(state)
    toggleOn = state
    toggleFlag.Value = state
end)

Tabs.Main:AddToggle("PredictMovementToggle", {
    Title = "Predict Movement",
    Default = predictMovement,
}):OnChanged(function(state)
    predictMovement = state
end)

-- ‚öîÔ∏è Setup
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer

local dangerousAnimations = {
    ["131430497821198"] = true,
    ["100592913030351"] = true,
    ["70447634862911"]  = true
}

local killerModels = {["1x1x1x1"] = true}
local survivorModels = {
    ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
    ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
    ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true
}

-- state
local autoRotateDisabledByScript = false
local currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false

-- utils
local function isKiller()
    local char = localPlayer.Character
    return char and killerModels[char.Name] or false
end

local function getMyHumanoid()
    local char = localPlayer.Character
    return char and char:FindFirstChildWhichIsA("Humanoid")
end

local function restoreAutoRotate()
    local hum = getMyHumanoid()
    if hum and autoRotateDisabledByScript then
        hum.AutoRotate = true
        autoRotateDisabledByScript = false
    end
end

local function isPlayingDangerousAnimation()
    local humanoid = getMyHumanoid()
    if not humanoid then return false end
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return false end

    for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
        local animId = tostring(track.Animation.AnimationId):match("%d+")
        if animId and dangerousAnimations[animId] then
            return true
        end
    end
    return false
end

local function getClosestSurvivor()
    local myHumanoid = getMyHumanoid()
    if not myHumanoid then return nil end
    local myRoot = myHumanoid.Parent and myHumanoid.Parent:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end

    local closest, closestDist = nil, math.huge
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and survivorModels[obj.Name] then
            local hrp = obj:FindFirstChild("HumanoidRootPart")
            local hum = obj:FindFirstChildWhichIsA("Humanoid")
            if hrp and hum and hum.Health > 0 then
                local dist = (hrp.Position - myRoot.Position).Magnitude
                if dist < closestDist then
                    closest = obj
                    closestDist = dist
                end
            end
        end
    end
    return closest
end

-- reset khi respawn
localPlayer.CharacterAdded:Connect(function()
    task.delay(0.1, function()
        autoRotateDisabledByScript = false
    end)
end)

-- üîÅ Main loop
RunService.RenderStepped:Connect(function(dt)
    if not toggleFlag.Value then
        restoreAutoRotate()
        currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
        return
    end

    if not isKiller() then
        restoreAutoRotate()
        currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
        return
    end

    local myHumanoid = getMyHumanoid()
    if not myHumanoid then return end
    local myRoot = myHumanoid.Parent and myHumanoid.Parent:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    local isPlaying = isPlayingDangerousAnimation()

    -- Lock target (ch·ªâ l·∫•y 1 l·∫ßn khi b·∫Øt ƒë·∫ßu animation)
    if isPlaying and not isLockedOn then
        currentTarget = getClosestSurvivor()
        if currentTarget then isLockedOn = true end
    end

    -- Validate current target
    if isLockedOn and currentTarget then
        local tHum, tHrp = currentTarget:FindFirstChildWhichIsA("Humanoid"), currentTarget:FindFirstChild("HumanoidRootPart")
        if (not tHum) or (tHum and tHum.Health <= 0) or (not tHrp) then
            currentTarget, isLockedOn = nil, false
        end
    end

    -- End animation -> reset
    if (not isPlaying) and wasPlayingAnimation then
        currentTarget, isLockedOn = nil, false
        restoreAutoRotate()
    end
    wasPlayingAnimation = isPlaying

    -- Aim/Teleport logic
    if isPlaying and isLockedOn and currentTarget and currentTarget:FindFirstChild("HumanoidRootPart") then
        local hrp = currentTarget.HumanoidRootPart
        local targetPos = hrp.Position
        if not autoRotateDisabledByScript then
            myHumanoid.AutoRotate = false
            autoRotateDisabledByScript = true
        end

        -- üßÆ Predict movement n·∫øu b·∫≠t toggle
        if predictMovement then
            local vel = hrp.Velocity
            if vel.Magnitude > 2 then -- ch·ªâ khi ƒëang di chuy·ªÉn
                targetPos = targetPos + hrp.CFrame.LookVector * 3
            end
        end

        local lookAt = Vector3.new(targetPos.X, myRoot.Position.Y, targetPos.Z)

        if aimMode == "One Player" then
            myRoot.CFrame = myRoot.CFrame:Lerp(CFrame.lookAt(myRoot.Position, lookAt), 0.99)

        elseif aimMode == "Multi Players" then
            local newTarget = getClosestSurvivor()
            if newTarget then currentTarget = newTarget end
            myRoot.CFrame = myRoot.CFrame:Lerp(CFrame.lookAt(myRoot.Position, lookAt), 0.99)

        elseif aimMode == "Teleport" then
            -- teleport ra sau l∆∞ng target trong su·ªët animation
            local targetLookVector = hrp.CFrame.LookVector
            local behindPos = hrp.Position - targetLookVector * 3 + Vector3.new(0, 0, 0)
            myRoot.CFrame = CFrame.new(behindPos, targetPos)
        end
    end
end)
end



    Tabs.Main:AddSection("‚Ü≥ Noli")

do
    -- noli void rush control (sandboxed)
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local voidrushcontrol = false
    local DEFAULT_SPEED = 16
    local DASH_SPEED = 60
    local isOverrideActive = false
    local connection
    local Humanoid, RootPart

    -- Setup nh√¢n v·∫≠t
    local function setupCharacter(character)
        Humanoid = character:WaitForChild("Humanoid")
        RootPart = character:WaitForChild("HumanoidRootPart")
    end

    if LocalPlayer.Character then
        setupCharacter(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(setupCharacter)

    -- B·∫Øt ƒë·∫ßu override void rush
    local function startOverride()
        if isOverrideActive or not Humanoid or not RootPart then return end
        isOverrideActive = true

        connection = RunService.RenderStepped:Connect(function()
            if not Humanoid or not RootPart or Humanoid.Health <= 0 then return end

            Humanoid.WalkSpeed = DASH_SPEED
            Humanoid.AutoRotate = false

            local direction = RootPart.CFrame.LookVector
            local horizontal = Vector3.new(direction.X, 0, direction.Z)
            if horizontal.Magnitude > 0 then
                Humanoid:Move(horizontal.Unit, true)
            end
        end)
    end

    -- D·ª´ng override void rush
    local function stopOverride()
        if not isOverrideActive then return end
        isOverrideActive = false

        if Humanoid then
            Humanoid.WalkSpeed = DEFAULT_SPEED
            Humanoid.AutoRotate = true
            Humanoid:Move(Vector3.zero, true)
        end

        if connection then
            connection:Disconnect()
            connection = nil
        end
    end

    -- Main loop: detect void rush state
    RunService.RenderStepped:Connect(function()
        if not voidrushcontrol or not Humanoid then return end

        local char = Humanoid.Parent
        local state = char and char:GetAttribute("VoidRushState")

        if state == "Dashing" then
            startOverride()
        else
            stopOverride()
        end
    end)

    -- === Th√™m toggle v√†o GUI ===
    Tabs.Main:AddToggle("VoidRushControl", {
        Title = "Void Rush Aimbot",
        Default = false
    }):OnChanged(function(val)
        voidrushcontrol = val
    end)
end




-- Tabs.Player

-- ======= D·ªäCH V·ª§ =======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ======= WHITELIST =======
local AllowedPlayers = {
    ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
    ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
    ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true,
    ["Dusekkar"] = true,
}

local AllowedKillers = {
    ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
    ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true,
}

-- ======= BI·∫æN TR·∫†NG TH√ÅI =======
local AimlockPlayerEnabled = false
local AimlockKillerEnabled = false
local CurrentTarget = nil

-- ======= H√ÄM H·ªñ TR·ª¢ =======
local function IsAllowed(model, list)
    return list[model.Name] == true
end

local function GetModelFromPlayer(plr, list)
    if not plr.Character then return nil end
    if IsAllowed(plr.Character, list) and plr.Character:FindFirstChildWhichIsA("Humanoid") then
        return plr.Character
    end
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
            if model:FindFirstChild("Owner") and model.Owner.Value == plr then
                if IsAllowed(model, list) then
                    return model
                end
            end
        end
    end
    return nil
end

local function GetClosestTarget(list)
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local model = GetModelFromPlayer(plr, list)
            if model and model.PrimaryPart then
                local humanoid = model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
                    if distance < dist then
                        dist = distance
                        closest = model
                    end
                end
            end
        end
    end
    return closest
end

-- ======= KI·ªÇM TRA TARGET HI·ªÜN T·∫†I =======
local function ValidateTarget(target)
    if not target then return false end
    local humanoid = target:FindFirstChildWhichIsA("Humanoid")
    return humanoid and humanoid.Health > 0 and target.PrimaryPart ~= nil
end

-- ======= AIMLOCK LOOP =======
RunService.RenderStepped:Connect(function()
    if AimlockPlayerEnabled then
        if not ValidateTarget(CurrentTarget) then
            CurrentTarget = GetClosestTarget(AllowedPlayers)
        end
        if ValidateTarget(CurrentTarget) then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, CurrentTarget.PrimaryPart.Position)
        end
    elseif AimlockKillerEnabled then
        if not ValidateTarget(CurrentTarget) then
            CurrentTarget = GetClosestTarget(AllowedKillers)
        end
        if ValidateTarget(CurrentTarget) then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, CurrentTarget.PrimaryPart.Position)
        end
    else
        -- n·∫øu t·∫Øt aimlock th√¨ reset target
        CurrentTarget = nil
    end
end)

-- ======= FLUENT TOGGLES =======
Tabs.Player:AddToggle("ForsakenAimlock", {
    Title = "Aimlock Player",
    Default = false
}):OnChanged(function(v)
    AimlockPlayerEnabled = v
    if v then 
        AimlockKillerEnabled = false
        CurrentTarget = nil -- reset ƒë·ªÉ ch·ªçn l·∫°i khi b·∫≠t
    end
end)

Tabs.Player:AddToggle("ForsakenAimlock1", {
    Title = "Aimlock Killer",
    Default = false
}):OnChanged(function(v)
    AimlockKillerEnabled = v
    if v then 
        AimlockPlayerEnabled = false
        CurrentTarget = nil -- reset ƒë·ªÉ ch·ªçn l·∫°i khi b·∫≠t
    end
end)




    Tabs.Player:AddSection("‚Ü≥ Cheats")
local ActiveNoStun = false
local noStunLoop

Tabs.Player:AddToggle("NoStunToggle", {
    Title = "No Stun",
    Default = false,
}):OnChanged(function(value)
    ActiveNoStun = value

    if value then
        -- N·∫øu c√≥ loop c≈© th√¨ d·ª´ng
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end

        -- T·∫°o loop m·ªõi li√™n t·ª•c ƒë·∫£m b·∫£o HumanoidRootPart kh√¥ng b·ªã anchore
        noStunLoop = task.spawn(function()
            while ActiveNoStun do
                local character = game.Players.LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Anchored = false
                end
                task.wait(0.1) -- Kh√¥ng c·∫ßn qu√° nhanh, tr√°nh lag
            end
        end)
    else
        -- T·∫Øt loop khi toggle off
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end
    end
end)







local InfStaminaEnabled = false  
local staminaLoop  
local StaminaModule  
  
-- Th·ª≠ l·∫•y module an to√†n  
pcall(function()  
    local ReplicatedStorage = game:GetService("ReplicatedStorage")  
    local path = ReplicatedStorage:FindFirstChild("Systems")  
        and ReplicatedStorage.Systems:FindFirstChild("Character")  
        and ReplicatedStorage.Systems.Character:FindFirstChild("Game")  
        and ReplicatedStorage.Systems.Character.Game:FindFirstChild("Sprinting")  
  
    if path then  
        StaminaModule = require(path)  
    end  
end)  
  
-- H√†m h·ªìi stamina an to√†n  
local function restoreStamina()  
    if not StaminaModule then return end  

    local maxStamina = StaminaModule.MaxStamina or 100  
    if StaminaModule.Stamina then  
        -- N·∫øu module c√≥ h√†m "SetStamina" th√¨ d√πng  
        if typeof(StaminaModule.SetStamina) == "function" then  
            StaminaModule:SetStamina(maxStamina)  

        -- N·∫øu c√≥ h√†m "UpdateStamina" th√¨ d√πng  
        elseif typeof(StaminaModule.UpdateStamina) == "function" then  
            StaminaModule:UpdateStamina(maxStamina)  

        -- N·∫øu kh√¥ng c√≥ th√¨ set tr·ª±c ti·∫øp  
        else  
            StaminaModule.Stamina = maxStamina  
        end  
    end  
end  
  
-- Ch·ªâ t·∫°o toggle n·∫øu module t·ªìn t·∫°i  
if StaminaModule then  
    Tabs.Player:AddToggle("InfStamina", {  
        Title = "Infinite Stamina",  
        Default = false  
    }):OnChanged(function(value)  
        -- lu√¥n b·ªçc trong pcall ƒë·ªÉ Fluent kh√¥ng b√°o "Callback error"  
        local ok = pcall(function()  
            InfStaminaEnabled = value  
            if StaminaModule.StaminaLossDisabled ~= nil then  
                StaminaModule.StaminaLossDisabled = value  
            end  
  
            if value then  
                restoreStamina()  
                if not staminaLoop then  
                    staminaLoop = task.spawn(function()  
                        while InfStaminaEnabled do  
                            task.wait(0.01)  
                            restoreStamina()  
                        end  
                        staminaLoop = nil  
                    end)  
                end  
            end  
        end)  
    end)  
else  
    warn("[InfStamina] Sprinting module not found, toggle disabled.")  
end



    Tabs.Player:AddSection("‚Ü≥ Troller")




Tabs.Player:AddButton({
    Title = "Fake Block",
    Callback = function()
        -- T·∫°o Animation object
        local animation = Instance.new("Animation")
        animation.AnimationId = "rbxassetid://72722244508749"

        -- L·∫•y Humanoid c·ªßa nh√¢n v·∫≠t
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")

        if humanoid then
            local animator = humanoid:FindFirstChildOfClass("Animator")
            if not animator then
                animator = Instance.new("Animator")
                animator.Parent = humanoid
            end

            -- Load v√† Play animation
            local animTrack = animator:LoadAnimation(animation)
            animTrack:Play()
        end
    end
})



Tabs.Player:AddButton({
    Title = "Fake Punch",
    Callback = function()
        -- T·∫°o Animation object
        local animation = Instance.new("Animation")
        animation.AnimationId = "rbxassetid://87259391926321"

        -- L·∫•y Humanoid c·ªßa nh√¢n v·∫≠t
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")

        if humanoid then
            local animator = humanoid:FindFirstChildOfClass("Animator")
            if not animator then
                animator = Instance.new("Animator")
                animator.Parent = humanoid
            end

            -- Load v√† Play animation
            local animTrack = animator:LoadAnimation(animation)
            animTrack:Play()
        end

        -- √Çm thanh ƒë·∫ßu ti√™n
        local sound1 = Instance.new("Sound")
        sound1.SoundId = "rbxassetid://81976396729343"
        sound1.Parent = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
        sound1:Play()

        -- Sau 0.75 gi√¢y th√¨ t·∫Øt sound1 v√† ph√°t sound2
        task.delay(0.75, function()
            if sound1.IsPlaying then
                sound1:Stop()
            end
            local sound2 = Instance.new("Sound")
            sound2.SoundId = "rbxassetid://122560631718612"
            sound2.Parent = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
            sound2:Play()
        end)
    end
})




Tabs.Player:AddButton({
    Title = "Fake Punch v2",
    Callback = function()
        -- T·∫°o Animation object
        local animation = Instance.new("Animation")
        animation.AnimationId = "rbxassetid://86709774283672"

        -- L·∫•y Humanoid c·ªßa nh√¢n v·∫≠t
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")

        if humanoid then
            local animator = humanoid:FindFirstChildOfClass("Animator")
            if not animator then
                animator = Instance.new("Animator")
                animator.Parent = humanoid
            end

            -- Load v√† Play animation
            local animTrack = animator:LoadAnimation(animation)
            animTrack:Play()
        end

        -- √Çm thanh ƒë·∫ßu ti√™n
        local sound1 = Instance.new("Sound")
        sound1.SoundId = "rbxassetid://81976396729343"
        sound1.Parent = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
        sound1:Play()

        -- Sau 0.5 gi√¢y th√¨ t·∫Øt sound1 v√† ph√°t sound2
        task.delay(0.5, function()
            if sound1.IsPlaying then
                sound1:Stop()
            end
            local sound2 = Instance.new("Sound")
            sound2.SoundId = "rbxassetid://122560631718612"
            sound2.Parent = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
            sound2:Play()
        end)
    end
})



do
-- L∆∞u callback Backflip ƒë·ªÉ toggle g·ªçi l·∫°i
local function doBackflip()
    local plr = game.Players.LocalPlayer
    local char = plr and plr.Character
    if not char then return end

    local hum = char:FindFirstChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local animator = hum and hum:FindFirstChildOfClass("Animator")
    if not (hum and hrp) then return end

    if char:FindFirstChild("Animate") then
        char.Animate.Disabled = true
    end

    if animator then
        for _, v in ipairs(animator:GetPlayingAnimationTracks()) do
            v:Stop()
        end
    end

    for _, s in ipairs({
        Enum.HumanoidStateType.FallingDown,
        Enum.HumanoidStateType.Freefall,
        Enum.HumanoidStateType.Running,
        Enum.HumanoidStateType.Seated,
        Enum.HumanoidStateType.Climbing
    }) do
        hum:SetStateEnabled(s, false)
    end
    hum:ChangeState(Enum.HumanoidStateType.Physics)

    local d, s = 0.45, 120
    local cf = hrp.CFrame
    local dir = cf.LookVector -- ‚úÖ bay theo h∆∞·ªõng nh√¨n
    local up = Vector3.yAxis

    task.spawn(function()
        local t0 = tick()
        for i = 1, s do
            local t = i / s
            local y = 4 * (t - t ^ 2) * 10
            local targetPos = cf.Position + dir * (35 * t) + up * y
            local r = CFrame.Angles(math.rad(360 * t), 0, 0)

            -- ‚úÖ Raycast check tr∆∞·ªõc khi PivotTo
            local rayParams = RaycastParams.new()
            rayParams.FilterDescendantsInstances = {char}
            rayParams.FilterType = Enum.RaycastFilterType.Blacklist

            local result = workspace:Raycast(hrp.Position, (targetPos - hrp.Position), rayParams)

            if result then
                -- N·∫øu c√≥ t∆∞·ªùng ch·∫∑n ‚Üí d·ª´ng t·∫°i v·ªã tr√≠ va ch·∫°m
                targetPos = result.Position + result.Normal * 2
            end

            char:PivotTo(CFrame.new(targetPos) * cf.Rotation * r)

            local wt = (d / s) * i - (tick() - t0)
            if wt > 0 then task.wait(wt) end
        end

        -- Ki·ªÉm tra va ch·∫°m t·∫°i ƒëi·ªÉm k·∫øt th√∫c
        local finalTarget = cf.Position + dir * 35
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {char}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local result = workspace:Raycast(hrp.Position, (finalTarget - hrp.Position), rayParams)
        if result then
            finalTarget = result.Position + result.Normal * 2
        end

        char:PivotTo(CFrame.new(finalTarget) * cf.Rotation)

        for _, s in ipairs({
            Enum.HumanoidStateType.FallingDown,
            Enum.HumanoidStateType.Freefall,
            Enum.HumanoidStateType.Running,
            Enum.HumanoidStateType.Seated,
            Enum.HumanoidStateType.Climbing
        }) do
            hum:SetStateEnabled(s, true)
        end
        hum:ChangeState(Enum.HumanoidStateType.Running)
        char.Animate.Disabled = false
    end)
end

-- N√∫t Backflip
Tabs.Player:AddButton({
    Title = "Backflip",
    -- Description = "Perform a backflip",
    Callback = doBackflip
})

-- Toggle Auto Backflip
local autoFlip = false
Tabs.Player:AddToggle("AutoBackflip", {
    Title = "Auto Backflip",
    Default = false,
    Callback = function(Value)
        autoFlip = Value
        if autoFlip then
            task.spawn(function()
                while autoFlip do
                    doBackflip()
                    task.wait(1.25)
                end
            end)
        end
    end
})
end





do
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer

    -- Animation object
    local fakeFixAnim = Instance.new("Animation")
    fakeFixAnim.AnimationId = "rbxassetid://82691533602949"

    local animator, fakeFixTrack

    -- H√†m t√¨m animator c·ªßa nh√¢n v·∫≠t
    local function getAnimator()
        local char = player.Character
        if not char then return nil end
        local humanoid = char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
        if not humanoid then return nil end
        local anim = humanoid:FindFirstChildOfClass("Animator")
        if not anim then
            anim = Instance.new("Animator")
            anim.Parent = humanoid
        end
        return anim
    end

    -- Toggle UI
    Tabs.Player:AddToggle("FakeFixGen", {
        Title = "Fake Fix Gen",
        Default = false,
        Callback = function(state)
            animator = getAnimator()
            if not animator then return end

            if state then
                if not fakeFixTrack then
                    local ok, track = pcall(function()
                        return animator:LoadAnimation(fakeFixAnim)
                    end)
                    if ok and track then
                        fakeFixTrack = track
                        fakeFixTrack.Looped = true
                        fakeFixTrack:Play()
                    end
                end
            else
                if fakeFixTrack then
                    fakeFixTrack:Stop()
                    fakeFixTrack = nil
                end
            end
        end
    })
end


    Tabs.Player:AddSection("‚Ü≥ Animation")

--// Fake Killers Anim System
do
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

-- th·ª≠ require sprint module (n·∫øu game c√≥)
local sprintModule
pcall(function()
    sprintModule = require(ReplicatedStorage:WaitForChild("Systems").Character.Game.Sprinting)
end)

-- state
local enabled = false
local selectedKiller = "Shasher" -- m·∫∑c ƒë·ªãnh
local character, humanoid, animator
local idleAnim, walkAnim, runAnim
local idleTrack, walkTrack, runTrack
local _isSprinting = false

-- conn
local runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn
local heartbeatAccumulator = 0
local HEARTBEAT_CHECK_INTERVAL = 0.12

-- anim sets
local animSets = {
    ["Shasher"] = {
        Idle = "rbxassetid://116050994905421",
        Walk = "rbxassetid://93622022596108",
        Run  = "rbxassetid://93054787145505",
    },
    ["Coolkidd"] = {
        Idle = "rbxassetid://18885903667",
        Walk = "rbxassetid://18885906143",
        Run  = "rbxassetid://96571077893813",
    },
    ["John Doe"] = {
        Idle = "rbxassetid://105880087711722",
        Walk = "rbxassetid://81193817424328",
        Run  = "rbxassetid://132653655520682",
    },
    ["Noli"] = {
        Idle = "rbxassetid://93841120533318",
        Walk = "rbxassetid://109700476007435",
        Run  = "rbxassetid://117451341682452",
    },
    ["1x1x1x1"] = {
        Idle = "rbxassetid://138754221537146",
        Walk = "rbxassetid://131235528875091",
        Run  = "rbxassetid://106485518413331",
    }
}

-- utility
local function stopAndClearTracks()
    for _, track in ipairs({idleTrack, walkTrack, runTrack}) do
        if track then pcall(function() track:Stop() end) end
    end
    idleTrack, walkTrack, runTrack = nil, nil, nil
end

local function disconnectListeners()
    for _, c in ipairs({runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn}) do
        if c then c:Disconnect() end
    end
    runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn = nil, nil, nil, nil, nil
end

local function cleanupCurrentCharacter()
    stopAndClearTracks()
    disconnectListeners()
    animator, humanoid, character = nil, nil, nil
end

-- load anim objects theo killer
local function loadAnimObjects(killer)
    local set = animSets[killer]
    if not set then return end

    idleAnim, walkAnim, runAnim = Instance.new("Animation"), Instance.new("Animation"), Instance.new("Animation")
    idleAnim.Name, walkAnim.Name, runAnim.Name = "IdleAnim", "WalkAnim", "RunAnim"
    idleAnim.AnimationId, walkAnim.AnimationId, runAnim.AnimationId = set.Idle, set.Walk, set.Run
end

-- play
local function playAnim(animObj, trackType)
    if not animator then return end

    -- stop other
    if trackType ~= "Idle" and idleTrack then pcall(function() idleTrack:Stop() end) idleTrack=nil end
    if trackType ~= "Walk" and walkTrack then pcall(function() walkTrack:Stop() end) walkTrack=nil end
    if trackType ~= "Run" and runTrack then pcall(function() runTrack:Stop() end) runTrack=nil end

    local track
    if trackType=="Idle" and not idleTrack then idleTrack = animator:LoadAnimation(idleAnim) track=idleTrack
    elseif trackType=="Walk" and not walkTrack then walkTrack = animator:LoadAnimation(walkAnim) track=walkTrack
    elseif trackType=="Run" and not runTrack then runTrack = animator:LoadAnimation(runAnim) track=runTrack
    else track = (trackType=="Idle" and idleTrack) or (trackType=="Walk" and walkTrack) or runTrack end

    if track and not track.IsPlaying then pcall(function() track:Play() end) end
end

local function playIdle() playAnim(idleAnim,"Idle") end
local function playWalk() playAnim(walkAnim,"Walk") end
local function playRun() playAnim(runAnim,"Run") end

-- update state
local function updateMovementState()
    if not enabled or not character then return end

    local moving=false
    if humanoid and humanoid.MoveDirection then
        moving = humanoid.MoveDirection.Magnitude>0
        if not moving then
            local root = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
            if root and root.Velocity.Magnitude>1 then moving=true end
        end
    end

    if moving then
        local sprintingNow = sprintModule and sprintModule.IsSprinting or _isSprinting
        if sprintingNow then playRun() else playWalk() end
    else
        playIdle()
    end
end

-- listeners
local function setupMovementListeners()
    disconnectListeners()
    inputBeganConn = UserInputService.InputBegan:Connect(function(input,gp) if gp then return end if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=true end end)
    inputEndedConn = UserInputService.InputEnded:Connect(function(input,gp) if gp then return end if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=false end end)

    if humanoid and humanoid.Running then
        runningConn = humanoid.Running:Connect(function(speed) if not enabled then return end if speed>0 then updateMovementState() else playIdle() end end)
    else
        heartbeatAccumulator=0
        heartbeatConn = RunService.Heartbeat:Connect(function(dt)
            if not enabled or not character then return end
            heartbeatAccumulator+=dt
            if heartbeatAccumulator>=HEARTBEAT_CHECK_INTERVAL then heartbeatAccumulator=0 updateMovementState() end
        end)
    end
end

-- bind character
local function onCharacterBound(char)
    cleanupCurrentCharacter()
    character=char
    humanoid=char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")

    if humanoid then
        animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    end

    characterRemovingConn = char.AncestryChanged:Connect(function(_,parent) if not parent then cleanupCurrentCharacter() end end)

    if enabled then
        loadAnimObjects(selectedKiller)
        setupMovementListeners()
        updateMovementState()
    end
end

-- characterAdded
player.CharacterAdded:Connect(onCharacterBound)
if player.Character then onCharacterBound(player.Character) end

-- UI

Tabs.Player:AddDropdown("ChooseKillersDropdown", {
    Title = "Choose Killers",
    Values = {"Shasher","Coolkidd","John Doe","Noli","1x1x1x1"},
    Default = "Shasher",
    Multi = false,
    Callback = function(value)
        selectedKiller = value
        if enabled and player.Character then
            loadAnimObjects(selectedKiller)
            stopAndClearTracks()
            updateMovementState()
        end
    end
})

Tabs.Player:AddToggle("FakeKillersToggle", {
    Title = "Fake Killers",
    Default = false,
    Callback = function(state)
        enabled = state
        if enabled then
            if player.Character then
                loadAnimObjects(selectedKiller)
                onCharacterBound(player.Character)
            end
        else
            stopAndClearTracks()
            disconnectListeners()
        end
    end
})
end

    Tabs.Player:AddSection("‚Ü≥ Hitbox")


repeat task.wait() until game:IsLoaded()

-- bi·∫øn c·∫•u h√¨nh
local ForsakenReachEnabled = false
local NearestDist = 120

-- th√™m toggle + slider v√†o Fluent (Tabs.Player b·∫°n ƒë√£ c√≥ s·∫µn)
Tabs.Player:AddToggle("ForsakenReachToggle", {
    Title = "Hitbox Devil",
    Default = false,
    Save = true
}):OnChanged(function(Value)
    ForsakenReachEnabled = Value
end)

Tabs.Player:AddSlider("ForsakenReachSlider", {
    Title = "Distance",
    Default = 120,
    Min = 10,
    Max = 300,
    Rounding = 0,
    Save = true,
    Suffix = " studs"
}):OnChanged(function(Value)
    NearestDist = Value
end)

-- services & player setup
local Players = game:GetService('Players')
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

Player.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end)

local RNG = Random.new()

-- full danh s√°ch animations gi·ªØ nguy√™n t·ª´ code 1
local AttackAnimations = {
    'rbxassetid://131430497821198',
    'rbxassetid://83829782357897',
    'rbxassetid://126830014841198',
    'rbxassetid://126355327951215',
    'rbxassetid://121086746534252',
    'rbxassetid://105458270463374',
    'rbxassetid://127172483138092',
    'rbxassetid://18885919947',
    'rbxassetid://18885909645',
    'rbxassetid://87259391926321',
    'rbxassetid://106014898528300',
    'rbxassetid://87259391926321',
    'rbxassetid://86545133269813',
    'rbxassetid://89448354637442',
    'rbxassetid://90499469533503',
    'rbxassetid://116618003477002',
    'rbxassetid://106086955212611',
    'rbxassetid://107640065977686',
    'rbxassetid://77124578197357',
    'rbxassetid://101771617803133',
    'rbxassetid://134958187822107',
    'rbxassetid://111313169447787',
    'rbxassetid://71685573690338',
    'rbxassetid://71685573690338',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://129843313690921',
    'rbxassetid://136007065400978',
    'rbxassetid://136007065400978',
    'rbxassetid://86096387000557',
    'rbxassetid://86096387000557',
    'rbxassetid://108807732150251',
    'rbxassetid://138040001965654',
    'rbxassetid://73502073176819',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://97623143664485',
    'rbxassetid://97623143664485',
    'rbxassetid://86709774283672',
    'rbxassetid://106014898528300',
    'rbxassetid://87259391926321',
    'rbxassetid://140703210927645',
    'rbxassetid://96173857867228',
    'rbxassetid://121255898612475',
    'rbxassetid://98031287364865',
    'rbxassetid://119462383658044',
    'rbxassetid://77448521277146',
    'rbxassetid://77448521277146',
    'rbxassetid://103741352379819',
    'rbxassetid://119462383658044',
    'rbxassetid://131696603025265',
    'rbxassetid://122503338277352',
    'rbxassetid://97648548303678',
    'rbxassetid://94162446513587',
    'rbxassetid://84426150435898',
    'rbxassetid://93069721274110',
    'rbxassetid://114620047310688',
    'rbxassetid://97433060861952',
    'rbxassetid://82183356141401',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://70447634862911',
    'rbxassetid://92173139187970',
    'rbxassetid://106847695270773',
    'rbxassetid://125403313786645',
    'rbxassetid://81639435858902',
    'rbxassetid://137314737492715',
    'rbxassetid://120112897026015',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://126681776859538',
    'rbxassetid://129976080405072',
    'rbxassetid://109667959938617',
    'rbxassetid://74707328554358',
    'rbxassetid://133336594357903',
    'rbxassetid://86204001129974',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://124243639579224',
    'rbxassetid://70371667919898',
    'rbxassetid://131543461321709',
    'rbxassetid://136323728355613',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://139835501033932',
    'rbxassetid://106538427162796'
}

-- danh s√°ch model killers v√† survivors (theo y√™u c·∫ßu c·ªßa b·∫°n)
local Killers = {
    ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
    ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true
}

local Survivors = {
    ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
    ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
    ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true
}

-- gom reach logic th√†nh h√†m (ƒë√£ ch·ªânh ƒë·ªÉ ∆∞u ti√™n nh·∫Øm phe ƒë·ªëi ngh·ªãch n·∫øu b·∫°n ·ªü d·∫°ng model)
local function ForsakenReachLogic()
    if not ForsakenReachEnabled or not HumanoidRootPart then
        return
    end

    -- ki·ªÉm tra animation attack (gi·ªØ nguy√™n)
    local Playing = false
    for _,v in Humanoid:GetPlayingAnimationTracks() do
        if table.find(AttackAnimations, v.Animation.AnimationId) and (v.TimePosition / v.Length < 0.75) then
            Playing = true
        end
    end

    if not Playing then
        return
    end

    -- x√°c ƒë·ªãnh b·∫°n ƒëang l√† model thu·ªôc phe n√†o (n·∫øu c√≥)
    local PlayerRole = nil -- "Killer" | "Survivor" | nil
    local myModelName = Character and Character.Name
    if myModelName and Killers[myModelName] then
        PlayerRole = "Killer"
    elseif myModelName and Survivors[myModelName] then
        PlayerRole = "Survivor"
    end

    local OppositeTable = nil
    if PlayerRole == "Killer" then
        OppositeTable = Survivors
    elseif PlayerRole == "Survivor" then
        OppositeTable = Killers
    end

    local Target = nil
    local CurrentNearestDist = NearestDist

    -- 1) N·∫øu b·∫°n ƒëang l√† model (c√≥ OppositeTable), ∆∞u ti√™n t√¨m m·ª•c ti√™u thu·ªôc phe ƒë·ªëi ngh·ªãch tr∆∞·ªõc
    local OppTarget = nil
    local OppNearestDist = NearestDist

    local function loopForOpp(t)
        for _,v in pairs(t) do
            if v == Character or not v:FindFirstChild("HumanoidRootPart") or not v:FindFirstChild("Humanoid") then
                continue
            end
            local modelName = v.Name
            if OppositeTable and OppositeTable[modelName] then
                local Dist = (v.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if Dist < OppNearestDist then
                    OppNearestDist = Dist
                    OppTarget = v
                end
            end
        end
    end

    if OppositeTable then
        loopForOpp(workspace.Players:GetDescendants())
        local npcsFolder = workspace.Map:FindFirstChild("NPCs", true)
        if npcsFolder then
            loopForOpp(npcsFolder:GetChildren())
        end
    end

    -- 2) N·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c phe ƒë·ªëi ngh·ªãch th√¨ fallback v·ªÅ logic g·ªëc nh∆∞ng v·∫´n b·ªè qua model c√πng phe v·ªõi b·∫°n
    local function loopAll(t)
        for _,v in pairs(t) do
            if v == Character or not v:FindFirstChild("HumanoidRootPart") or not v:FindFirstChild("Humanoid") then
                continue
            end
            local modelName = v.Name
            -- b·ªè qua c√πng phe n·∫øu b·∫°n ƒëang ·ªü d·∫°ng model
            if PlayerRole == "Killer" and Killers[modelName] then
                continue
            end
            if PlayerRole == "Survivor" and Survivors[modelName] then
                continue
            end
            local Dist = (v.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
            if Dist < CurrentNearestDist then
                CurrentNearestDist = Dist
                Target = v
            end
        end
    end

    -- n·∫øu t√¨m th·∫•y OppTarget th√¨ d√πng lu√¥n, kh√¥ng c·∫ßn t√¨m ti·∫øp
    local FinalTarget = nil
    if OppTarget then
        FinalTarget = OppTarget
    else
        -- fallback: qu√©t players + npcs gi·ªëng tr∆∞·ªõc nh∆∞ng ƒë√£ lo·∫°i c√πng phe
        loopAll(workspace.Players:GetDescendants())
        local npcsFolder2 = workspace.Map:FindFirstChild("NPCs", true)
        if npcsFolder2 then
            loopAll(npcsFolder2:GetChildren())
        end
        FinalTarget = Target
    end

    if not FinalTarget then
        return
    end

    -- gi·ªØ nguy√™n ph·∫ßn t√≠nh velocity + √°p d·ª•ng hit
    local OldVelocity = HumanoidRootPart.Velocity
    local NeededVelocity =
        (FinalTarget.HumanoidRootPart.Position + Vector3.new(
            RNG:NextNumber(-1.5, 1.5),
            0,
            RNG:NextNumber(-1.5, 1.5)
        ) + (FinalTarget.HumanoidRootPart.Velocity * (Player:GetNetworkPing() * 1.25))
            - HumanoidRootPart.Position
        ) / (Player:GetNetworkPing() * 2)

    HumanoidRootPart.Velocity = NeededVelocity
    game:GetService('RunService').RenderStepped:Wait()
    HumanoidRootPart.Velocity = OldVelocity
end

-- v√≤ng l·∫∑p auto g·ªçi l·∫°i m·ªói 0s (gi·ªØ nguy√™n)
task.spawn(function()
    while true do
        task.wait(0)
        pcall(ForsakenReachLogic)
    end
end)




    Tabs.Player:AddSection("‚Ü≥ Walk Speed")


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local ValueSpeed = 16
local ActiveSpeedBoost = false
local speedLoop

local function setSpeed(speed)
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = speed
        humanoid:SetAttribute("BaseSpeed", speed)
    end
end

-- Khi respawn √°p d·ª•ng l·∫°i t·ªëc ƒë·ªô n·∫øu b·∫≠t
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.1)
    if ActiveSpeedBoost then
        setSpeed(ValueSpeed)
    end
end)

-- Slider ch·ªânh t·ªëc ƒë·ªô
Tabs.Player:AddSlider("PlayerSpeedSlider", {
    Title = "Set Speed",
    Min = 0,
    Max = 40,
    Default = ValueSpeed,
    Rounding = 1,
}):OnChanged(function(value)
    ValueSpeed = value
    if ActiveSpeedBoost then
        setSpeed(ValueSpeed)
    end
end)

-- Toggle b·∫≠t/t·∫Øt t·ªëc ƒë·ªô v√† loop tƒÉng t·ªëc li√™n t·ª•c
Tabs.Player:AddToggle("PlayerSpeedToggle", {
    Title = "Walk Speed",
    Default = false,
}):OnChanged(function(value)
    ActiveSpeedBoost = value
    if value then
        setSpeed(ValueSpeed)
        -- B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p li√™n t·ª•c set t·ªëc ƒë·ªô m·ªói 0.5 gi√¢y
        speedLoop = task.spawn(function()
            while ActiveSpeedBoost do
                setSpeed(ValueSpeed)
                task.wait(0.5)
            end
        end)
    else
        -- T·∫Øt v√≤ng l·∫∑p v√† reset t·ªëc ƒë·ªô v·ªÅ m·∫∑c ƒë·ªãnh 16
        if speedLoop then
            speedLoop = nil
        end
        setSpeed(16)
    end
end)



    Tabs.Player:AddSection("‚Ü≥ Teleport Speed")


-- === Teleport Speed Setup ===
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HRP = Character:WaitForChild("HumanoidRootPart")

local defaultSpeed = 50
local maxSpeed = 300
local currentSpeed = defaultSpeed
local teleportSpeedEnabled = false

-- C·∫≠p nh·∫≠t l·∫°i khi respawn
LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    Humanoid = Character:WaitForChild("Humanoid")
    HRP = Character:WaitForChild("HumanoidRootPart")
end)

-- Loop ƒë·ªÉ d·ªãch chuy·ªÉn (teleport speed)
RunService.Heartbeat:Connect(function(dt)
    if teleportSpeedEnabled and Humanoid and HRP then
        if Humanoid.MoveDirection.Magnitude > 0 then
            local moveDir = Humanoid.MoveDirection.Unit
            HRP.CFrame = HRP.CFrame + (moveDir * (currentSpeed * dt))
        end
    end
end)

-- === GUI Bindings ===
-- Slider Teleport Speed
Tabs.Player:AddSlider("TeleportSpeedSlider", {
    Title = "Set Speed",
    Min = 1,
    Max = maxSpeed,
    Default = defaultSpeed,
    Rounding = 1,
}):OnChanged(function(value)
    currentSpeed = value
end)

-- Toggle b·∫≠t/t·∫Øt Teleport Speed
Tabs.Player:AddToggle("TeleportSpeedToggle", {
    Title = "Teleport Speed",
    Default = false,
}):OnChanged(function(enabled)
    teleportSpeedEnabled = enabled
end)

     

-- Tabs.Visual

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- üìå Danh s√°ch model Clone
local allowedModelsClone = {
    ["1x1x1x1Zombie"] = true,
    ["PizzaDeliveryRig"] = true,
    ["Mafia1"] = true,
    ["Mafia2"] = true,
    ["Mafia3"] = true,
    ["Mafia4"] = true,
}

-- Internal containers
local drawingsClone = {}
local espConnectionClone
local addedConnClone, removedConnClone

-- T·∫°o/kh√¥i ph·ª•c ESP + Highlight (t·ª± h·ªìi ph·ª•c n·∫øu m·∫•t)
local function createOrRepairESP(model, drawings, color)
    if not model then return end

    local data = drawings[model]
    if not data then
        -- Ch·ªâ kh·ªüi t·∫°o khi c√≥ HRP
        local hrp = model:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color

        local highlight = Instance.new("Highlight")
        highlight.Adornee = model
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = model

        drawings[model] = { text = text, highlight = highlight }
        return
    end

    -- H·ªìi ph·ª•c n·∫øu m·∫•t th√†nh ph·∫ßn
    if not data.text then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color
        data.text = text
    end
    if (not data.highlight) or (not data.highlight.Parent) then
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        local highlight = Instance.new("Highlight")
        highlight.Adornee = model
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = model
        data.highlight = highlight
    else
        -- ƒê·∫£m b·∫£o lu√¥n b√°m ƒë√∫ng model
        data.highlight.Adornee = model
        data.highlight.Enabled = true
        data.highlight.FillColor = color
        data.highlight.OutlineColor = color
    end
end

-- Xo√° ESP
local function removeESP(model, drawings)
    local data = drawings[model]
    if data then
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    drawings[model] = nil
end

-- Qu√©t workspace v√† t·∫°o ESP
local function scanWorkspaceForAllowed(allowedList, drawings, color)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedList[obj.Name] and obj:FindFirstChild("HumanoidRootPart") then
            createOrRepairESP(obj, drawings, color)
        end
    end
end

-- üî• B·∫Øt ƒë·∫ßu ESP Clone
function startESPClone()
    if espConnectionClone then return end

    local COLOR = Color3.fromRGB(0, 255, 0) -- xanh l√°
    scanWorkspaceForAllowed(allowedModelsClone, drawingsClone, COLOR)

    espConnectionClone = RunService.RenderStepped:Connect(function()
        for model, data in pairs(drawingsClone) do
            -- Lu√¥n t·ª± h·ªìi ph·ª•c n·∫øu m·∫•t
            createOrRepairESP(model, drawingsClone, COLOR)
            data = drawingsClone[model]

            if model.Parent and model:FindFirstChild("HumanoidRootPart") then
                local hrp = model.HumanoidRootPart
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

                if data.text then
                    data.text.Text = string.format("%s [%.0fm]", model.Name, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                end

                if data.highlight then
                    data.highlight.Enabled = true
                end
            else
                if data.text then data.text.Visible = false end
                if data.highlight then data.highlight.Enabled = false end
            end
        end
    end)

    addedConnClone = workspace.DescendantAdded:Connect(function(obj)
        -- B·∫Øt c·∫£ khi add v√†o s√¢u trong model
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedModelsClone[model.Name] then
            createOrRepairESP(model, drawingsClone, COLOR)
        end
    end)

    removedConnClone = workspace.DescendantRemoving:Connect(function(obj)
        -- N·∫øu model ho·∫∑c ancestor c·ªßa n√≥ n·∫±m trong b·∫£ng, xo√° ESP
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsClone[model] then
            removeESP(model, drawingsClone)
        end
    end)
end

-- üõë D·ª´ng ESP Clone
function stopESPClone()
    if espConnectionClone then espConnectionClone:Disconnect() end
    if addedConnClone then addedConnClone:Disconnect() end
    if removedConnClone then removedConnClone:Disconnect() end
    for _, data in pairs(drawingsClone) do
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    table.clear(drawingsClone)
    espConnectionClone, addedConnClone, removedConnClone = nil, nil, nil
end

-- üìå Toggle ESP Clone
Tabs.Visual:AddToggle("ESPCloneToggle", {
    Title = "ESP Clone",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        startESPClone()
    else
        stopESPClone()
    end
end)






do
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local drawingsESP = {}
local espConnection, addedConn, removingConn

-- üé® M√†u xanh l∆°
local ESP_COLOR = Color3.fromRGB(0, 255, 255)

-- üìå T·∫°o ho·∫∑c s·ª≠a ESP cho Player
local function createOrRepairESP(player)
    if not player.Character then return end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local data = drawingsESP[player]
    if not data then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = ESP_COLOR

        local highlight = Instance.new("Highlight")
        highlight.Adornee = player.Character
        highlight.FillColor = ESP_COLOR
        highlight.OutlineColor = ESP_COLOR
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = player.Character

        drawingsESP[player] = { text = text, highlight = highlight }
        return
    end

    -- N·∫øu m·∫•t th√¨ h·ªìi ph·ª•c
    if not data.text then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = ESP_COLOR
        data.text = text
    end
    if (not data.highlight) or (not data.highlight.Parent) then
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        local highlight = Instance.new("Highlight")
        highlight.Adornee = player.Character
        highlight.FillColor = ESP_COLOR
        highlight.OutlineColor = ESP_COLOR
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = player.Character
        data.highlight = highlight
    else
        -- ƒë·∫£m b·∫£o lu√¥n b√°m v√†o Character
        data.highlight.Adornee = player.Character
        data.highlight.Enabled = true
        data.highlight.FillColor = ESP_COLOR
        data.highlight.OutlineColor = ESP_COLOR
    end
end

-- üìå Xo√° ESP
local function removeESP(player)
    local data = drawingsESP[player]
    if data then
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    drawingsESP[player] = nil
end

-- üìå Qu√©t to√†n b·ªô Player hi·ªán t·∫°i
local function scanAllPlayers()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            createOrRepairESP(player)
        end
    end
end

-- üî• B·∫≠t ESP
local function startESP()
    if espConnection then return end

    scanAllPlayers()

    espConnection = RunService.RenderStepped:Connect(function()
        for player, data in pairs(drawingsESP) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = player.Character.HumanoidRootPart
                createOrRepairESP(player)
                data = drawingsESP[player]

                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

                if data.text then
                    data.text.Text = string.format("%s [%.0fm]", player.Name, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                end

                if data.highlight then
                    data.highlight.Enabled = true
                end
            else
                if data.text then data.text.Visible = false end
                if data.highlight then data.highlight.Enabled = false end
            end
        end
    end)

    addedConn = Players.PlayerAdded:Connect(function(player)
        if player ~= LocalPlayer then
            player.CharacterAdded:Connect(function()
                task.wait(1) -- ch·ªù Character load
                createOrRepairESP(player)
            end)
        end
    end)

    removingConn = Players.PlayerRemoving:Connect(function(player)
        removeESP(player)
    end)
end

-- üõë T·∫Øt ESP
local function stopESP()
    if espConnection then espConnection:Disconnect() end
    if addedConn then addedConn:Disconnect() end
    if removingConn then removingConn:Disconnect() end

    for _, data in pairs(drawingsESP) do
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    table.clear(drawingsESP)
    espConnection, addedConn, removingConn = nil, nil, nil
end

-- üìå Toggle UI
Tabs.Visual:AddToggle("ESPPlayerToggle", {
    Title = "ESP Player",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        startESP()
    else
        stopESP()
    end
end)
end







do
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")

-- Danh s√°ch model
local allowedModelsWhite = {
    ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
    ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
    ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true,
}

local allowedModelsRed = {
    ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
    ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true
}

-- Containers
local drawingsWhite, drawingsRed = {}, {}
local conWhiteLoop, conWhiteAdded, conWhiteRemoved
local conRedLoop, conRedAdded, conRedRemoved

-- Check model c√≥ ph·∫£i player ƒëi·ªÅu khi·ªÉn kh√¥ng
local function isControlledByPlayer(model)
    if model:FindFirstChildOfClass("Humanoid") then
        local plr = Players:GetPlayerFromCharacter(model)
        return plr ~= nil
    end
    return false
end

-- Utility t·∫°o/repair ESP
local function createOrRepairESP(model, drawings, color)
    if not model then return end

    local data = drawings[model]
    if not data then
        local hrp = model:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        -- Text
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color

        -- Highlight
        local highlight = Instance.new("Highlight")
        highlight.Adornee = model
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = model

        drawings[model] = { text = text, highlight = highlight }
        return
    end

    -- Repair n·∫øu m·∫•t
    if not data.text then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color
        data.text = text
    end
    if not (data.highlight and data.highlight.Parent) then
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        local highlight = Instance.new("Highlight")
        highlight.Adornee = model
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = model
        data.highlight = highlight
    end
end

local function removeESP(model, drawings)
    local data = drawings[model]
    if data then
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    drawings[model] = nil
end

-- Loop ESP update
local function updateESP(drawings, color)
    for model, data in pairs(drawings) do
        if model.Parent and model:FindFirstChild("HumanoidRootPart") then
            createOrRepairESP(model, drawings, color)
            data = drawings[model]

            local hrp = model.HumanoidRootPart
            local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
            local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

            if data.text then
                local displayName = model.Name

                -- Check ri√™ng cho Noli
                if model.Name == "Noli" and not isControlledByPlayer(model) then
                    displayName = "Noli Fake"
                end

                data.text.Text = string.format("%s [%.0fm]", displayName, dist)
                data.text.Position = Vector2.new(pos.X, pos.Y)
                data.text.Visible = onScreen
            end

            if data.highlight then
                data.highlight.Adornee = model
                data.highlight.Enabled = true
            end
        else
            if data.text then data.text.Visible = false end
            if data.highlight then data.highlight.Enabled = false end
        end
    end
end

-- === White ESP ===
local function startESPWhite()
    if conWhiteLoop then return end
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedModelsWhite[obj.Name] then
            createOrRepairESP(obj, drawingsWhite, Color3.fromRGB(255, 255, 255))
        end
    end

    conWhiteLoop = RunService.Heartbeat:Connect(function()
        updateESP(drawingsWhite, Color3.fromRGB(255, 255, 255))
    end)

    conWhiteAdded = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedModelsWhite[model.Name] then
            createOrRepairESP(model, drawingsWhite, Color3.fromRGB(255, 255, 255))
        end
    end)
    conWhiteRemoved = workspace.DescendantRemoving:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsWhite[model] then
            removeESP(model, drawingsWhite)
        end
    end)
end

local function stopESPWhite()
    if conWhiteLoop then conWhiteLoop:Disconnect(); conWhiteLoop = nil end
    if conWhiteAdded then conWhiteAdded:Disconnect(); conWhiteAdded = nil end
    if conWhiteRemoved then conWhiteRemoved:Disconnect(); conWhiteRemoved = nil end
    for _, d in pairs(drawingsWhite) do
        pcall(function() if d.text then d.text:Remove() end end)
        pcall(function() if d.highlight then d.highlight:Destroy() end end)
    end
    drawingsWhite = {}
end

-- === Red ESP ===
local function startESPRed()
    if conRedLoop then return end
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedModelsRed[obj.Name] then
            createOrRepairESP(obj, drawingsRed, Color3.fromRGB(255, 0, 0))
        end
    end

    conRedLoop = RunService.Heartbeat:Connect(function()
        updateESP(drawingsRed, Color3.fromRGB(255, 0, 0))
    end)

    conRedAdded = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedModelsRed[model.Name] then
            createOrRepairESP(model, drawingsRed, Color3.fromRGB(255, 0, 0))
        end
    end)
    conRedRemoved = workspace.DescendantRemoving:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsRed[model] then
            removeESP(model, drawingsRed)
        end
    end)
end

local function stopESPRed()
    if conRedLoop then conRedLoop:Disconnect(); conRedLoop = nil end
    if conRedAdded then conRedAdded:Disconnect(); conRedAdded = nil end
    if conRedRemoved then conRedRemoved:Disconnect(); conRedRemoved = nil end
    for _, d in pairs(drawingsRed) do
        pcall(function() if d.text then d.text:Remove() end end)
        pcall(function() if d.highlight then d.highlight:Destroy() end end)
    end
    drawingsRed = {}
end

-- Toggles
Tabs.Visual:AddToggle("ESPModelWhiteToggle", {
    Title = "ESP Survivors",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then startESPWhite() else stopESPWhite() end
end)

Tabs.Visual:AddToggle("ESPModelRedToggle", {
    Title = "ESP Killers",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then startESPRed() else stopESPRed() end
end)
end




-- === ESP Generator (Highlight) ===
local highlights, progressConns = {}, {}
local espLoop
local espEnabled = false
local genAddedConn, genRemovedConn

-- L·∫•y generators trong map
local function getGenerators()
    local list = {}
    local mapRoot = workspace:FindFirstChild("Map")
    local ingame = mapRoot and mapRoot:FindFirstChild("Ingame")
    local mapFolder = ingame and ingame:FindFirstChild("Map")

    for _, obj in ipairs((mapFolder or ingame or mapRoot or workspace):GetDescendants()) do
        if obj:IsA("Model") and obj.Name == "Generator" then
            if not obj.PrimaryPart then
                local part = obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")
                if part then
                    pcall(function() obj.PrimaryPart = part end)
                end
            end
            table.insert(list, obj)
        end
    end
    return list
end

local function isCompleted(gen)
    local p = gen:FindFirstChild("Progress")
    return p and tonumber(p.Value) and p.Value >= 100
end

local function ensureHighlight(gen)
    if highlights[gen] then
        highlights[gen].Enabled = true
        return
    end
    local h = Instance.new("Highlight")
    h.Adornee = gen
    h.FillColor = Color3.fromRGB(255,255,255)
    h.OutlineColor = Color3.fromRGB(255,255,255)
    h.FillTransparency = 0.5
    h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    h.Parent = gen
    highlights[gen] = h
end

local function cleanupModel(gen)
    if progressConns[gen] then
        progressConns[gen]:Disconnect()
        progressConns[gen] = nil
    end
    if highlights[gen] then
        highlights[gen]:Destroy()
        highlights[gen] = nil
    end
end

local function watchProgress(gen)
    if progressConns[gen] then return end
    local p = gen:FindFirstChild("Progress")
    if not p then return end
    progressConns[gen] = p.Changed:Connect(function()
        if not espEnabled then return end
        if isCompleted(gen) then
            if highlights[gen] then highlights[gen].Enabled = false end
        else
            ensureHighlight(gen)
        end
    end)
end

local function startESPGen()
    if espEnabled then return end
    espEnabled = true

    -- Loop c·∫≠p nh·∫≠t m·ªói 0.5s
    espLoop = task.spawn(function()
        while espEnabled do
            for _, gen in ipairs(getGenerators()) do
                if isCompleted(gen) then
                    if highlights[gen] then highlights[gen].Enabled = false end
                else
                    ensureHighlight(gen)
                end
                watchProgress(gen)
            end
            -- cleanup generator b·ªã xo√°
            for gen,_ in pairs(highlights) do
                if not gen:IsDescendantOf(workspace) then
                    cleanupModel(gen)
                end
            end
            task.wait(0.5)
        end
    end)

    -- K·∫øt n·ªëi spawn/remove
    genAddedConn = workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("Model") and obj.Name == "Generator" then
            task.defer(function()
                if isCompleted(obj) then
                    if highlights[obj] then highlights[obj].Enabled = false end
                else
                    ensureHighlight(obj)
                end
                watchProgress(obj)
            end)
        end
    end)

    genRemovedConn = workspace.DescendantRemoving:Connect(function(obj)
        if highlights[obj] or progressConns[obj] then
            cleanupModel(obj)
        end
    end)
end

local function stopESPGen()
    espEnabled = false
    if espLoop then espLoop = nil end
    if genAddedConn then genAddedConn:Disconnect(); genAddedConn = nil end
    if genRemovedConn then genRemovedConn:Disconnect(); genRemovedConn = nil end
    for gen,_ in pairs(progressConns) do
        cleanupModel(gen)
    end
end

-- Toggle GUI
Tabs.Visual:AddToggle("ESPGeneratorToggle", {
    Title = "ESP Generator",
    Default = false,
}):OnChanged(function(state)
    if state then startESPGen() else stopESPGen() end
end)





do
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local itemsDraw = {}
local conItemsAdded, conItemsRemoved, conItemsLoop

local function getToolPart(tool)
    return tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
end

local function createItemESP(tool)
    if itemsDraw[tool] then return end
    local part = getToolPart(tool)
    if not part then return end

    local text = Drawing.new("Text")
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Visible = false
    text.Color = Color3.fromRGB(255, 215, 0)

    local hl = Instance.new("Highlight")
    hl.Name = "ItemESP_Highlight"
    hl.Adornee = part
    hl.FillColor = Color3.fromRGB(255, 215, 0)
    hl.OutlineColor = Color3.fromRGB(255, 215, 0)
    hl.FillTransparency = 0.7
    hl.OutlineTransparency = 0
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    hl.Enabled = true
    hl.Parent = tool

    itemsDraw[tool] = {text = text, highlight = hl, part = part}
end

local function removeItemESP(tool)
    local data = itemsDraw[tool]
    if not data then return end
    pcall(function() if data.text then data.text:Remove() end end)
    pcall(function() if data.highlight then data.highlight:Destroy() end end)
    itemsDraw[tool] = nil
end

local function isInIngameFolder(inst)
    local map = workspace:FindFirstChild("Map")
    local ingame = map and map:FindFirstChild("Ingame")
    return ingame and inst:IsDescendantOf(ingame)
end

local function scanInitialItems()
    local map = workspace:FindFirstChild("Map")
    local ingame = map and map:FindFirstChild("Ingame")
    if not ingame then return end
    for _, obj in ipairs(ingame:GetDescendants()) do
        if obj:IsA("Tool") then
            createItemESP(obj)
        end
    end
end

local function startESPItems()
    if conItemsLoop then return end

    scanInitialItems()

    -- Ch·ªâ qu√©t c√°c tool m·ªõi th√™m
    conItemsAdded = workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("Tool") and isInIngameFolder(obj) then
            createItemESP(obj)
        end
    end)

    conItemsRemoved = workspace.DescendantRemoving:Connect(function(obj)
        if itemsDraw[obj] then
            removeItemESP(obj)
        end
    end)

    -- C·∫≠p nh·∫≠t v·ªã tr√≠ text m·ªói frame
    conItemsLoop = RunService.RenderStepped:Connect(function()
        for tool, data in pairs(itemsDraw) do
            local part = data.part
            if not (tool.Parent and part and part.Parent) or not isInIngameFolder(tool) then
                data.text.Visible = false
            else
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position + Vector3.new(0,2,0))
                local dist = (part.Position - Camera.CFrame.Position).Magnitude
                data.text.Text = string.format("%s [%.0fm]", tool.Name, dist)
                data.text.Position = Vector2.new(pos.X, pos.Y)
                data.text.Visible = onScreen
                if data.highlight then
                    data.highlight.Adornee = part
                    data.highlight.Enabled = true
                end
            end
        end
    end)
end

local function stopESPItems()
    if conItemsAdded then conItemsAdded:Disconnect(); conItemsAdded = nil end
    if conItemsRemoved then conItemsRemoved:Disconnect(); conItemsRemoved = nil end
    if conItemsLoop then conItemsLoop:Disconnect(); conItemsLoop = nil end
    for tool, _ in pairs(itemsDraw) do
        removeItemESP(tool)
    end
    itemsDraw = {}
end

Tabs.Visual:AddToggle("ESPItemsToggle", {
    Title = "ESP Items",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then startESPItems() else stopESPItems() end
end)
end



-- Tabs.Misc

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

-- ‚úÖ FullBright Settings
local fullBrightEnabled = false
local fullBrightLoop

local function applyFullBright()
    if not fullBrightEnabled then return end

    Lighting.Ambient = Color3.fromRGB(200, 200, 200) -- s√°ng nh·∫π
    Lighting.Brightness = 4 -- gi·∫£m ƒë·ªô s√°ng t·ª´ 10 ‚Üí 4
    Lighting.GlobalShadows = false
end

local function enableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() end
    applyFullBright()
    fullBrightLoop = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
end

local function disableFullBright()
    if fullBrightLoop then
        fullBrightLoop:Disconnect()
        fullBrightLoop = nil
    end

    Lighting.Ambient = Color3.fromRGB(128, 128, 128)
    Lighting.Brightness = 1
    Lighting.GlobalShadows = true
end

-- ‚úÖ Toggle: FullBright
local FbToggle = Tabs.Misc:AddToggle("FbToggle", {
    Title = "Auto Full Bright",
    Default = false
})
FbToggle:OnChanged(function(Value)
    fullBrightEnabled = Value
    if fullBrightEnabled then
        enableFullBright()
    else
        disableFullBright()
    end
end)

-- ‚úÖ Remove Fog Settings
local fogEnabled = false
local fogLoop

local function removeFog()
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0
        atmosphere.Offset = 0
        atmosphere.Haze = 0
        atmosphere.Color = Color3.new(1, 1, 1)
    end
end

local function restoreFog()
    Lighting.FogStart = 200
    Lighting.FogEnd = 1000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0.3
        atmosphere.Offset = 0
        atmosphere.Haze = 0.5
        atmosphere.Color = Color3.fromRGB(200, 200, 200)
    end
end

-- ‚úÖ Toggle: Remove Fog
local FogToggle = Tabs.Misc:AddToggle("FogToggle", {
    Title = "Remove Fog",
    Default = false
})
FogToggle:OnChanged(function(Value)
    fogEnabled = Value
    if fogEnabled then
        removeFog()
        fogLoop = RunService.Heartbeat:Connect(removeFog)
    else
        if fogLoop then fogLoop:Disconnect() fogLoop = nil end
        restoreFog()
    end
end)



local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local PlayerGui = LP:WaitForChild("PlayerGui")

local ActiveRemoveEffects = false

-- Danh s√°ch t√™n hi·ªáu ·ª©ng th∆∞·ªùng g·∫∑p
local effectNames = {
    "BlurEffect", "ColorCorrectionEffect", "BloomEffect", "SunRaysEffect", 
    "DepthOfFieldEffect", "ScreenFlash", "HitEffect", "DamageOverlay", 
    "BloodEffect", "Vignette", "BlackScreen", "WhiteScreen", "ShockEffect",
    "Darkness", "JumpScare", "LowHealthOverlay", "Flashbang", "FadeEffect"
}

-- Danh s√°ch class hi·ªáu ·ª©ng trong Lighting
local effectClasses = {
    "BlurEffect",
    "BloomEffect",
    "SunRaysEffect",
    "DepthOfFieldEffect",
    "ColorCorrectionEffect"
}

-- H√†m xo√° hi·ªáu ·ª©ng
local function removeEffects()
    -- Xo√° hi·ªáu ·ª©ng trong Lighting
    for _, obj in pairs(Lighting:GetDescendants()) do
        if table.find(effectNames, obj.Name) or table.find(effectClasses, obj.ClassName) then
            obj:Destroy()
        end
    end

    -- Xo√° GUI overlay
    for _, obj in pairs(PlayerGui:GetDescendants()) do
        if table.find(effectNames, obj.Name) then
            obj:Destroy()
        elseif obj:IsA("ScreenGui") or obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
            if obj:FindFirstChildWhichIsA("ImageLabel") or obj:FindFirstChildWhichIsA("Frame") then
                if table.find(effectNames, obj.Name) or obj.Name:lower():find("overlay") or obj.Name:lower():find("effect") then
                    obj:Destroy()
                end
            end
        end
    end
end

-- Toggle Fluent
Tabs.Misc:AddToggle("RemoveScreenEffects", {
    Title = "Remove Effects",
    Default = true,
    Callback = function(state)
        ActiveRemoveEffects = state
        if state then
            task.spawn(function()
                while ActiveRemoveEffects do
                    removeEffects()
                    task.wait(0.5)
                end
            end)
        end
    end
})


    Tabs.Misc:AddSection("‚Ü≥ Bypass")

local antiAFKCons = {}

-- Ch·ªâ t·∫°o toggle n·∫øu executor c√≥ getconnections
if getconnections then
    Tabs.Misc:AddToggle("AntiAFK", {
        Title = "Anti-AFK",
        Default = true
    }):OnChanged(function(state)
        local idleCons = getconnections(game.Players.LocalPlayer.Idled)
        
        if state then
            -- L∆∞u & disable
            for _, c in ipairs(idleCons) do
                antiAFKCons[c] = true
                c:Disable()
            end
            print("[AntiAFK] ƒê√£ b·∫≠t, b·∫°n s·∫Ω kh√¥ng b·ªã kick AFK.")
        else
            -- Enable l·∫°i
            for c,_ in pairs(antiAFKCons) do
                if c and c.Enable then
                    pcall(function() c:Enable() end)
                end
            end
            antiAFKCons = {}
            print("[AntiAFK] ƒê√£ t·∫Øt, Roblox s·∫Ω x·ª≠ l√Ω AFK b√¨nh th∆∞·ªùng.")
        end
    end)
else
    warn("[AntiAFK] Executor kh√¥ng h·ªó tr·ª£ getconnections, toggle b·ªã v√¥ hi·ªáu.")
end








do
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local LocalizationService = game:GetService("LocalizationService")

    shared.AntiBanSafe = shared.AntiBanSafe or {running = false, hooks = {}}
    local data = shared.AntiBanSafe

    local oldNamecall, oldIndex
    local protectionThread

    local function safe(func, ...)
        local ok, res = pcall(func, ...)
        if ok then return res end
    end

    -- Disable screenshot/video flags khi b·∫≠t protection
    local function disableReportFlags()
        if typeof(setfflag) == "function" then
            pcall(function()
                setfflag("AbuseReportScreenshot", "False")
                setfflag("AbuseReportScreenshotPercentage", "0") -- ch·ªânh v·ªÅ 0
                setfflag("AbuseReportEnabled", "False")
                setfflag("ReportAbuseMenu", "False")
                setfflag("EnableAbuseReportScreenshot", "False")
                setfflag("AbuseReportVideo", "False")
                setfflag("AbuseReportVideoPercentage", "0")
                setfflag("VideoCaptureEnabled", "False")
                setfflag("RecordVideo", "False")
            end)
        end
    end

    -- Restore flag v·ªÅ b√¨nh th∆∞·ªùng khi t·∫Øt protection
    local function setFlagsOn()
        if typeof(setfflag) == "function" then
            pcall(function()
                setfflag("AbuseReportScreenshot", "True")
                setfflag("AbuseReportScreenshotPercentage", "100")
            end)
        end
    end

    -- Hook requests (block report)
    local function hookRequests()
        if data.hooks.requestHooked then return end
        local oldRequest = (syn and syn.request) or request or http_request
        if typeof(oldRequest) == "function" and typeof(hookfunction) == "function" then
            hookfunction(oldRequest, function(req)
                if req and req.Url and tostring(req.Url):lower():find("abuse") then
                    return {StatusCode = 200, Body = "Blocked"}
                end
                return oldRequest(req)
            end)
            data.hooks.requestHooked = true
        end
    end

    -- Hook FindFirstChild (block GUI video/screenshot)
    local function hookFindFirstChild()
        if data.hooks.findHooked then return end
        local oldFind = workspace.FindFirstChild
        if typeof(oldFind) == "function" and typeof(hookfunction) == "function" then
            hookfunction(oldFind, function(self, name, ...)
                if name and tostring(name):lower():find("screenshot") then return nil end
                if name and tostring(name):lower():find("video") then return nil end
                return oldFind(self, name, ...)
            end)
            data.hooks.findHooked = true
        end
    end

    -- Safe bypass (__namecall)
    local function safeBypass()
        if getrawmetatable and hookmetamethod and newcclosure then
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            oldNamecall = oldNamecall or mt.__namecall
            oldIndex = oldIndex or mt.__index

            mt.__namecall = newcclosure(function(self, ...)
                local method = getnamecallmethod()
                local args = {...}

                -- Block LocalPlayer kick/ban
                if (method == "Kick" or method == "Ban") and self == LocalPlayer then return nil end

                -- Block remote kick/ban
                if (method == "FireServer" or method == "InvokeServer") and args[1] then
                    local msg = tostring(args[1]):lower()
                    if msg:find("kick") or msg:find("ban") then return nil end
                end

                -- Block LocalizationService
                if self == LocalizationService and method == "GetCountryRegionForPlayerAsync" then
                    local success, result = pcall(function()
                        return LocalizationService:GetCountryRegionForPlayerAsync(LocalPlayer)
                    end)
                    if success then return result else return "US" end
                end

                return oldNamecall(self, ...)
            end)

            mt.__index = newcclosure(function(t, k)
                local key = tostring(k):lower()
                if key:find("kick") or key:find("ban") then return function() return nil end end
                return oldIndex(t, k)
            end)

            setreadonly(mt, true)
        end
    end

    -- Restore hooks
    local function restoreHooks()
        if getrawmetatable then
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            if oldNamecall then mt.__namecall = oldNamecall end
            if oldIndex then mt.__index = oldIndex end
            setreadonly(mt, true)
            oldNamecall, oldIndex = nil, nil
        end
    end

    -- Start protection
    local function startAntiBanSafe()
        if data.running then return end
        data.running = true

        safe(hookRequests)
        safe(hookFindFirstChild)
        safe(safeBypass)

        -- Disable screenshot/video
        protectionThread = task.spawn(function()
            while data.running do
                safe(disableReportFlags)
                task.wait(0.2)
            end
        end)

        print("[Anti-Ban Safe] üõ°Ô∏è ENABLED!")
    end

    -- Stop protection
    local function stopAntiBanSafe()
        data.running = false
        protectionThread = nil
        restoreHooks()
        setFlagsOn() -- ph·ª•c h·ªìi flag v·ªÅ b√¨nh th∆∞·ªùng
        print("[Anti-Ban Safe] ‚ö†Ô∏è DISABLED!")
    end

    -- Toggle
    Tabs.Misc:AddToggle("AntiBanV3", {
        Title = "Anti Ban V3",
        Default = true,
        Callback = function(state)
            if state then
                startAntiBanSafe()
            else
                stopAntiBanSafe()
            end
        end
    })
end







do
-- === SafeGenTeleport (Anti: ALL Moving Models/Parts/Effects) ===
local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local SafeGenRunning = false
local SafeGenThread

-- Danh s√°ch account th·∫≠t d√πng V2
local AllowedPlayers = {
    ["Hu1a0_Hu9"] = true,
    ["hdksakst"] = true
}

-- Danh s√°ch Killers
local DangerousKillers = {
    Slasher = true, ["1x1x1x1"] = true, c00lkidd = true,
    Noli = true, JohnDoe = true, Quest666 = true,
    PizzaDeliveryRig = true, Mafia1 = true, Mafia2 = true,
    ["1x1x1x1Zombie"] = true
}

-- Danh s√°ch Clones (coi nh∆∞ Killers)
local DangerousClones = {
    PizzaDeliveryRig = true, Mafia1 = true, Mafia2 = true,
    ["1x1x1x1Zombie"] = true
}

-- Danh s√°ch Survivors (b·∫°n c√≥ th·ªÉ bi·∫øn th√†nh)
local Survivors = {
    Noob = true, Guest1337 = true, Elliot = true, Shedletsky = true,
    TwoTime = true, ["007n7"] = true, Chance = true,
    Builderman = true, Taph = true, Dusekkar = true
}

-- Whitelist: t√™n object/model/part KH√îNG b·ªã t√≠nh l√† nguy hi·ªÉm (t√πy b·∫°n s·ª≠a)
local SafeObjects = {
    Pet = true,
    Decoration = true,
    Terrain = true,
    Map = true
}

-- C·∫•u h√¨nh detect
local MOVE_THRESHOLD = 0.5     -- thay ƒë·ªïi l·ªõn h∆°n MOVE_THRESHOLD (stud) gi·ªØa 2 tick => moving
local VEL_THRESHOLD  = 1       -- AssemblyLinearVelocity magnitude > VEL_THRESHOLD => moving
local DETECT_RADIUS  = 70      -- b√°n k√≠nh (stud) ƒë·ªÉ coi l√† "g·∫ßn b·∫°n"
local SCAN_DELAY     = 0.12    -- th·ªùi gian gi·ªØa 2 l·∫ßn scan (gi·∫£m n·∫øu mu·ªën nh·∫°y h∆°n; tƒÉng n·∫øu lag)

-- b·∫£ng l∆∞u v·ªã tr√≠ l·∫ßn tr∆∞·ªõc ƒë·ªÉ so s√°nh
local lastPositions = {}

-- helper: t√¨m ancestor Character v√† Player (n·∫øu c√≥)
local function findOwningCharacter(inst)
    local cur = inst
    while cur and cur ~= workspace and cur.Parent do
        if cur:IsA("Model") then
            local p = Players:GetPlayerFromCharacter(cur)
            if p then
                return cur, p
            end
        end
        cur = cur.Parent
    end
    return nil, nil
end

-- helper: check xem part c√≥ force/constraint types g·∫Øn ·ªü n√≥ (g·ª£i √Ω l√† ƒëang b·ªã ƒëi·ªÅu khi·ªÉn)
local function hasForceOnPart(part)
    if not part then return false end
    -- c√°c l·ªõp th∆∞·ªùng d√πng ƒë·ªÉ ƒëi·ªÅu khi·ªÉn v·∫≠n ƒë·ªông
    if part:FindFirstChildOfClass("BodyVelocity")
    or part:FindFirstChildOfClass("BodyPosition")
    or part:FindFirstChildOfClass("BodyForce")
    or part:FindFirstChildOfClass("BodyGyro")
    or part:FindFirstChildOfClass("LinearVelocity")
    or part:FindFirstChildOfClass("VectorForce")
    or part:FindFirstChildOfClass("AlignPosition")
    or part:FindFirstChildOfClass("AlignOrientation") then
        return true
    end
    return false
end

-- ki·ªÉm tra 1 BasePart c√≥ "di chuy·ªÉn" hay kh√¥ng (so v·ªõi lastPositions / velocity / force)
local function isPartMoving(part)
    if not part or not part:IsA("BasePart") then return false end
    local ok, asmVel = pcall(function() return part.AssemblyLinearVelocity end)
    local velMag = 0
    if ok and asmVel then
        velMag = asmVel.Magnitude or 0
    else
        -- fallback: try part.Velocity
        local ok2, v2 = pcall(function() return part.Velocity end)
        if ok2 and v2 then velMag = v2.Magnitude end
    end

    local last = lastPositions[part]
    local pos = part.Position
    local moved = false

    if last then
        local dist = (pos - last).Magnitude
        if dist >= MOVE_THRESHOLD then
            moved = true
        end
    else
        -- n·∫øu m·ªõi xu·∫•t hi·ªán, coi l√† moving n·∫øu c√≥ velocity ho·∫∑c force
        if velMag >= VEL_THRESHOLD or hasForceOnPart(part) then
            moved = true
        end
    end

    -- c·∫≠p nh·∫≠t lastPositions
    lastPositions[part] = pos
    -- n·∫øu c√≥ velocity l·ªõn ho·∫∑c force th√¨ ch·∫Øc ch·∫Øn moving
    if velMag >= VEL_THRESHOLD or hasForceOnPart(part) then
        moved = true
    end

    return moved
end

-- d·ªçn b·∫£ng lastPositions (lo·∫°i entry kh√¥ng c√≤n trong workspace)
local function pruneLastPositions()
    for inst, _ in pairs(lastPositions) do
        if not inst or not inst.Parent then
            lastPositions[inst] = nil
        end
    end
end

-- H√†m ch√≠nh: ki·ªÉm tra c√≥ v·∫≠t "di chuy·ªÉn" nguy hi·ªÉm g·∫ßn position trong radius kh√¥ng
local function isDangerNear(position, radius)
    -- 1) Ki·ªÉm tra tr·ª±c ti·∫øp folder Killers (n·∫øu Killer model ƒë·ª©ng g·∫ßn)
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, killer in ipairs(killersFolder:GetChildren()) do
            local hrp = killer:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (hrp.Position - position).Magnitude
                if (DangerousKillers[killer.Name] or DangerousClones[killer.Name]) and dist <= radius then
                    return true
                end
            end
        end
    end

    -- 2) Qu√©t t·∫•t c·∫£ BasePart trong workspace (nh·∫≠n di·ªán projectiles, traps, effects g·∫Øn tr√™n part, model parts...)
    for _, inst in ipairs(workspace:GetDescendants()) do
        if inst:IsA("BasePart") then
            -- skip n·∫øu t√™n thu·ªôc whitelist
            if SafeObjects[inst.Name] then
                -- ti·∫øp t·ª•c
            else
                local dist = (inst.Position - position).Magnitude
                if dist <= radius then
                    -- n·∫øu part ƒëang "di chuy·ªÉn" -> nghi√™m tr·ªçng
                    if isPartMoving(inst) then
                        -- ki·ªÉm tra owner (n·∫±m trong 1 character c·ªßa player th·∫≠t kh√¥ng)
                        local charModel, playerOwner = findOwningCharacter(inst)
                        if playerOwner then
                            -- n·∫øu thu·ªôc player th·∫≠t: b·ªè qua tr·ª´ khi t√™n character l√† killer/clone
                            local charName = charModel and charModel.Name or ""
                            if DangerousKillers[charName] or DangerousClones[charName] then
                                return true
                            else
                                -- player th·∫≠t ƒëi·ªÅu khi·ªÉn => ignore
                            end
                        else
                            -- kh√¥ng ph·∫£i player th·∫≠t => NPC / skill / projectile / trap ‚Üí nguy hi·ªÉm
                            return true
                        end
                    end
                end
            end
        end
    end

    -- prune c√°c entry c≈©
    pruneLastPositions()
    return false
end

-- Teleport t·ªõi generator an to√†n (gi·ªØ nguy√™n logic c·ªßa b·∫°n)
local function teleportToSafeGenerator()
    local character = LP.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local myPos = character.HumanoidRootPart.Position
    local bestGen, bestDistance = nil, 0

    local mapFolder = workspace:FindFirstChild("Map")
        and workspace.Map:FindFirstChild("Ingame")
        and workspace.Map.Ingame:FindFirstChild("Map")
    if not mapFolder then return end

    for _, gen in ipairs(mapFolder:GetChildren()) do
        if gen.Name == "Generator" and gen:FindFirstChild("Progress") then
            local success, pivot = pcall(function() return gen:GetPivot() end)
            if not success or not pivot then continue end
            local genPos = pivot.Position
            local dist = (myPos - genPos).Magnitude

            -- ch·ªçn generator xa & kh√¥ng c√≥ Danger g·∫ßn
            if dist > bestDistance and not isDangerNear(genPos, 40) then
                bestDistance = dist
                bestGen = gen
            end
        end
    end

    if bestGen then
        local offset = CFrame.new(0, 5, -3)
        local goalCFrame = bestGen:GetPivot() * offset
        if character and character.PrimaryPart then
            character:PivotTo(goalCFrame)
        else
            -- fallback
            local hrp = character and character:FindFirstChild("HumanoidRootPart")
            if hrp then hrp.CFrame = goalCFrame end
        end
        print("‚úÖ Teleported safely to generator:", bestGen.Name)
    else
        print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y generator an to√†n!")
    end
end

-- === Toggle GUI ===
Tabs.Misc:AddToggle("SafeGenTeleport", {
    Title = "Anti Killers V6",
    Default = false
}):OnChanged(function(state)
    SafeGenRunning = state
    if state then
        SafeGenThread = task.spawn(function()
            local delayTime = SCAN_DELAY
            if AllowedPlayers[LP.Name] then
                print("üöÄ V2 Mode enabled for:", LP.Name)
                delayTime = 0.01
            else
                print("üê¢ V1 Mode enabled for:", LP.Name)
            end

            while SafeGenRunning do
                local character = LP.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local charName = character.Name

                    if DangerousKillers[charName] or DangerousClones[charName] then
                        -- N·∫øu b·∫°n l√† killer/clone ‚Üí kh√¥ng teleport
                    elseif Survivors[charName] or charName == LP.Name then
                        if isDangerNear(hrp.Position, DETECT_RADIUS) then
                            teleportToSafeGenerator()
                        end
                    end
                end
                task.wait(delayTime)
            end
        end)
    else
        SafeGenRunning = false
        SafeGenThread = nil
        print("[SafeGenTeleport] ƒê√£ t·∫Øt.")
    end
end)
end




-- N√∫t Auto Teleport Cao (1 l·∫ßn duy nh·∫•t khi b·∫≠t)
Tabs.Misc:AddToggle("AutoTeleportHigh", {
    Title = "Anti Bug",
    Default = true
})
:OnChanged(function(Value)
    if Value then
        local char = LP.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            -- Teleport l√™n cao th√™m 10 studs
            char:PivotTo(char.HumanoidRootPart.CFrame + Vector3.new(0, 5, 0))
        end
    end
end)


    Tabs.Misc:AddSection("‚Ü≥ Fix Lag")

-- SCRIPT GI·∫¢M ƒê·ªí H·ªåA T·ª∞ ƒê·ªòNG M·ªñI 10 GI√ÇY (C√ì TOGGLE + RESTORE)
-- D√°n v√†o LocalScript (StarterPlayerScripts ho·∫∑c executor)
-- Si√™u Fix Lag c·ª±c m·∫°nh gi√∫p m√°y b·∫°n m∆∞·ª£t h∆°n 25% khi b·∫≠t

-- L∆∞u d·ªØ li·ªáu g·ªëc
local originalLighting = {}
local originalParts = {}

-- H√†m l∆∞u Lighting g·ªëc
local function saveLighting()
    originalLighting.QualityLevel = settings().Rendering.QualityLevel
    originalLighting.GlobalShadows = game.Lighting.GlobalShadows
    originalLighting.FogEnd = game.Lighting.FogEnd
    originalLighting.Brightness = game.Lighting.Brightness
    originalLighting.PostEffects = {}
    for _, v in ipairs(game.Lighting:GetChildren()) do
        if v:IsA("PostEffect") then
            originalLighting.PostEffects[v] = v.Enabled
        end
    end
end

-- H√†m kh√¥i ph·ª•c Lighting
local function restoreLighting()
    if not originalLighting.QualityLevel then return end
    settings().Rendering.QualityLevel = originalLighting.QualityLevel
    game.Lighting.GlobalShadows = originalLighting.GlobalShadows
    game.Lighting.FogEnd = originalLighting.FogEnd
    game.Lighting.Brightness = originalLighting.Brightness
    for effect, state in pairs(originalLighting.PostEffects) do
        if effect and effect.Parent == game.Lighting then
            effect.Enabled = state
        end
    end
end

-- H√†m gi·∫£m ƒë·ªì h·ªça tri·ªát ƒë·ªÉ
local function simplifyModel(obj)
    if obj:IsA("BasePart") then
        if not originalParts[obj] then
            originalParts[obj] = {
                Material = obj.Material,
                Color = obj.Color,
                Reflectance = obj.Reflectance,
                CastShadow = obj.CastShadow
            }
        end
        obj.Material = Enum.Material.SmoothPlastic
        obj.Color = Color3.fromRGB(163, 162, 165)
        obj.Reflectance = 0
        obj.CastShadow = false
    elseif obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("SurfaceAppearance") then
        obj:Destroy()
    elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
        obj.Enabled = false
    end
end

-- H√†m kh√¥i ph·ª•c BasePart
local function restoreParts()
    for part, data in pairs(originalParts) do
        if part and part.Parent then
            part.Material = data.Material
            part.Color = data.Color
            part.Reflectance = data.Reflectance
            part.CastShadow = data.CastShadow
        end
    end
    originalParts = {} -- reset
end

-- ==============================
-- Toggle Auto Reduce (10s)
-- ==============================
local autoThread
local connection

local AutoReduceToggle = Tabs.Misc:AddToggle("AutoReduce", {
    Title = "FPS Boost",
    Default = false,
    Callback = function(state)
        if state then
            print("üîÑ Auto Reduce ON")

            -- L∆∞u lighting g·ªëc
            saveLighting()

            -- Gi·∫£m ƒë·ªì h·ªça lighting khi b·∫≠t
            settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
            game.Lighting.GlobalShadows = false
            game.Lighting.FogEnd = 9e9
            game.Lighting.Brightness = 1
            for _, v in ipairs(game.Lighting:GetChildren()) do
                if v:IsA("PostEffect") then
                    v.Enabled = false
                end
            end

            -- üî• Gi·∫£m ngay 1 l·∫ßn ƒë·∫ßu ti√™n
            for _, obj in ipairs(workspace:GetDescendants()) do
                simplifyModel(obj)
            end

            -- N·∫øu c√≥ object spawn th√™m th√¨ c≈©ng x·ª≠ l√Ω
            connection = workspace.DescendantAdded:Connect(simplifyModel)

            -- Sau ƒë√≥ auto l·∫∑p m·ªói 10s
            autoThread = task.spawn(function()
                while AutoReduceToggle.Value do
                    task.wait(10)
                    for _, obj in ipairs(workspace:GetDescendants()) do
                        simplifyModel(obj)
                    end
                end
            end)

        else
            print("‚èπ Auto Reduce OFF")
            if connection then
                connection:Disconnect()
                connection = nil
            end

            -- Kh√¥i ph·ª•c ƒë·ªì h·ªça g·ªëc
            restoreLighting()
            restoreParts()
            print("‚úÖ ƒê√£ kh√¥i ph·ª•c ƒë·ªì h·ªça g·ªëc")
        end
    end
})



Tabs.Misc:AddToggle("UnlockFPS", { -- "UnlockFPS" l√† ID toggle
    Title = "Unlock FPS",
    Default = true,
    Callback = function(v)
        if setfpscap then
            setfpscap(v and 1000 or 60)
        end
    end
}) 

    Tabs.Misc:AddSection("‚Ü≥ Show")

-- FPS + Ping Drawing Setup
local showFPS = true
local showPing = true

local fpsText = Drawing.new("Text")
fpsText.Size = 16
fpsText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 10)
fpsText.Color = Color3.fromRGB(0, 255, 0)
fpsText.Center = false
fpsText.Outline = true
fpsText.Visible = showFPS

local msText = Drawing.new("Text")
msText.Size = 16
msText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 30)
msText.Color = Color3.fromRGB(0, 255, 0)
msText.Center = false
msText.Outline = true
msText.Visible = showPing

local fpsCounter = 0
local fpsLastUpdate = tick()

RunService.RenderStepped:Connect(function()
    fpsCounter += 1
    if tick() - fpsLastUpdate >= 1 then
        -- Update FPS
        if showFPS then
            fpsText.Text = "FPS: " .. tostring(fpsCounter)
            fpsText.Visible = true
        else
            fpsText.Visible = false
        end

        -- Update Ping
        if showPing then
            local pingStat = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]
            local ping = pingStat and math.floor(pingStat:GetValue()) or 0
            msText.Text = "Ping: " .. ping .. " ms"

            if ping <= 60 then
                msText.Color = Color3.fromRGB(0, 255, 0)
            elseif ping <= 120 then
                msText.Color = Color3.fromRGB(255, 165, 0)
            else
                msText.Color = Color3.fromRGB(255, 0, 0)
            end

            msText.Visible = true
        else
            msText.Visible = false
        end

        fpsCounter = 0
        fpsLastUpdate = tick()
    end
end)

-- ‚úÖ Fluent GUI Toggles chu·∫©n
local fpsToggle = Tabs.Misc:AddToggle("ShowFPSToggle", {
    Title = "Show FPS",
    Default = true
})
fpsToggle:OnChanged(function(val)
    showFPS = val
    fpsText.Visible = val
end)

local pingToggle = Tabs.Misc:AddToggle("ShowPingToggle", {
    Title = "Show Ping",
    Default = true
})
pingToggle:OnChanged(function(val)
    showPing = val
    msText.Visible = val
end)






do
-- LocalScript: Custom mirror of Roblox chat (view + send + collapse)
-- Place in StarterPlayerScripts or StarterGui

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TextChatService = game:GetService("TextChatService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- === CONFIG ===
local USE_RICHTEXT = true

-- === ScreenGui ===
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CustomChatGUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- === Frame ch√≠nh ===
local chatFrame = Instance.new("Frame")
chatFrame.Name = "ChatFrame"
chatFrame.Size = UDim2.fromScale(0.32, 0.42)
chatFrame.AnchorPoint = Vector2.new(0.5, 0.5)
chatFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
chatFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
chatFrame.BackgroundTransparency = 0.25
chatFrame.BorderSizePixel = 0
chatFrame.Active = true
chatFrame.ClipsDescendants = true
chatFrame.Parent = screenGui

local sizeConstraint = Instance.new("UISizeConstraint")
sizeConstraint.MaxSize = Vector2.new(660, 480)
sizeConstraint.MinSize = Vector2.new(260, 32) -- khi thu g·ªçn ch·ªâ c·∫ßn title
sizeConstraint.Parent = chatFrame

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 12)
uiCorner.Parent = chatFrame

-- === Thanh ti√™u ƒë·ªÅ ===
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 28)
titleBar.BackgroundTransparency = 1
titleBar.Parent = chatFrame

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Size = UDim2.new(1, -40, 1, 0) -- ch·ª´a ch·ªó cho n√∫t thu g·ªçn
title.Position = UDim2.new(0, 6, 0, 0)
title.Font = Enum.Font.SourceSansSemibold
title.TextSize = 18
title.TextXAlignment = Enum.TextXAlignment.Left
title.TextColor3 = Color3.fromRGB(240, 240, 240)
title.Text = "Khung chat ·∫£o"
title.Parent = titleBar

-- N√∫t thu g·ªçn
local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "ToggleBtn"
toggleBtn.Size = UDim2.new(0, 28, 0, 24)
toggleBtn.Position = UDim2.new(1, -32, 0.5, -12)
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
toggleBtn.Text = "-"
toggleBtn.Font = Enum.Font.SourceSansBold
toggleBtn.TextSize = 20
toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
toggleBtn.Parent = titleBar

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 6)
toggleCorner.Parent = toggleBtn

-- Vi·ªÅn m·ªèng
local stroke = Instance.new("UIStroke")
stroke.Thickness = 1
stroke.Transparency = 0.6
stroke.Color = Color3.fromRGB(255,255,255)
stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
stroke.Parent = chatFrame

-- === ScrollingFrame ===
local scroll = Instance.new("ScrollingFrame")
scroll.Name = "Messages"
scroll.Size = UDim2.new(1, -10, 1, -72)
scroll.Position = UDim2.new(0, 5, 0, 34)
scroll.BackgroundTransparency = 1
scroll.BorderSizePixel = 0
scroll.ScrollBarThickness = 6
scroll.ScrollingDirection = Enum.ScrollingDirection.Y
scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
scroll.CanvasSize = UDim2.new(0,0,0,0)
scroll.Parent = chatFrame

local padding = Instance.new("UIPadding")
padding.PaddingTop = UDim.new(0, 4)
padding.PaddingBottom = UDim.new(0, 6)
padding.PaddingLeft = UDim.new(0, 6)
padding.PaddingRight = UDim.new(0, 6)
padding.Parent = scroll

local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, 4)
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Parent = scroll

layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
	scroll.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 8)
end)

-- === Input bar ===
local inputBar = Instance.new("Frame")
inputBar.Name = "InputBar"
inputBar.Size = UDim2.new(1, -10, 0, 32)
inputBar.Position = UDim2.new(0, 5, 1, -36)
inputBar.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
inputBar.BackgroundTransparency = 0.2
inputBar.BorderSizePixel = 0
inputBar.Parent = chatFrame

local inputCorner = Instance.new("UICorner")
inputCorner.CornerRadius = UDim.new(0, 8)
inputCorner.Parent = inputBar

local textBox = Instance.new("TextBox")
textBox.Name = "ChatInput"
textBox.Size = UDim2.new(1, -50, 1, 0)
textBox.Position = UDim2.new(0, 6, 0, 0)
textBox.BackgroundTransparency = 1
textBox.Font = Enum.Font.SourceSans
textBox.TextSize = 18
textBox.TextXAlignment = Enum.TextXAlignment.Left
textBox.PlaceholderText = "Nh·∫≠p tin nh·∫Øn..."
textBox.TextColor3 = Color3.fromRGB(255,255,255)
textBox.Parent = inputBar

local sendBtn = Instance.new("TextButton")
sendBtn.Name = "SendBtn"
sendBtn.Size = UDim2.new(0, 44, 1, 0)
sendBtn.Position = UDim2.new(1, -44, 0, 0)
sendBtn.BackgroundColor3 = Color3.fromRGB(50, 120, 255)
sendBtn.Text = "‚û§"
sendBtn.Font = Enum.Font.SourceSansBold
sendBtn.TextSize = 20
sendBtn.TextColor3 = Color3.fromRGB(255,255,255)
sendBtn.Parent = inputBar

local sendCorner = Instance.new("UICorner")
sendCorner.CornerRadius = UDim.new(0, 8)
sendCorner.Parent = sendBtn

-- === Collapse logic ===
local collapsed = false
local fullHeight = chatFrame.Size -- l∆∞u size g·ªëc

toggleBtn.MouseButton1Click:Connect(function()
	collapsed = not collapsed
	if collapsed then
		scroll.Visible = false
		inputBar.Visible = false
		chatFrame.Size = UDim2.new(chatFrame.Size.X.Scale, chatFrame.Size.X.Offset, 0, 32)
		toggleBtn.Text = "+"
	else
		scroll.Visible = true
		inputBar.Visible = true
		chatFrame.Size = fullHeight
		toggleBtn.Text = "-"
	end
end)

-- === Helper: strip tag ===
local function stripTags(str)
	return (str:gsub("<[^>]->", ""))
end

-- === Add message ===
local function addMessage(text, speaker)
	local msg = Instance.new("TextLabel")
	msg.Name = "Msg"
	msg.BackgroundTransparency = 1
	msg.TextXAlignment = Enum.TextXAlignment.Left
	msg.TextWrapped = true
	msg.RichText = USE_RICHTEXT
	msg.Font = Enum.Font.SourceSans
	msg.TextSize = 18
	msg.TextColor3 = Color3.fromRGB(255, 255, 255)
	msg.AutomaticSize = Enum.AutomaticSize.Y
	msg.Size = UDim2.new(1, 0, 0, 0)

	if not USE_RICHTEXT then
		text = stripTags(text or "")
	end

	msg.Text = string.format("[%s]: %s", speaker or "H·ªá th·ªëng", text or "")
	msg.Parent = scroll

	task.defer(function()
		scroll.CanvasPosition = Vector2.new(0, 1e7)
	end)
end

-- === K√©o/th·∫£ ===
do
	local dragging, dragInput, dragStart, startPos
	local function update(input)
		local delta = input.Position - dragStart
		chatFrame.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end
	titleBar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = chatFrame.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	titleBar.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then
			update(input)
		end
	end)
end

-- === Nh·∫≠n chat ===
local function hookTextChatService()
	TextChatService.MessageReceived:Connect(function(message)
		local text = message and message.Text or ""
		local speaker = "H·ªá th·ªëng"
		if message then
			if message.PrefixText and #message.PrefixText > 0 then
				speaker = message.PrefixText:gsub(":%s*$","")
			elseif message.TextSource then
				local p = Players:GetPlayerByUserId(message.TextSource.UserId)
				speaker = (p and p.DisplayName) or "Ng∆∞·ªùi ch∆°i"
			end
		end
		addMessage(text, speaker)
	end)
end

local function hookLegacyChat()
	local chatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
	if not chatEvents then return end
	local onMsg = chatEvents:FindFirstChild("OnMessageDoneFiltering")
	if not onMsg then return end
	onMsg.OnClientEvent:Connect(function(data)
		addMessage(data.Message, data.FromSpeaker or "H·ªá th·ªëng")
	end)
end

-- === G·ª≠i chat ===
local function sendChat(text)
	if not text or text == "" then return end
	if TextChatService and TextChatService.ChatInputBarConfiguration then
		local channel = TextChatService.ChatInputBarConfiguration.TargetTextChannel
		if channel then
			channel:SendAsync(text)
			return
		end
	end
	local chatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
	if chatEvents then
		local sayMsg = chatEvents:FindFirstChild("SayMessageRequest")
		if sayMsg then
			sayMsg:FireServer(text, "All")
			return
		end
	end
end

sendBtn.MouseButton1Click:Connect(function()
	sendChat(textBox.Text)
	textBox.Text = ""
end)
textBox.FocusLost:Connect(function(enterPressed)
	if enterPressed then
		sendChat(textBox.Text)
		textBox.Text = ""
	end
end)

-- Hook
local okNew = false
pcall(function()
	if TextChatService and TextChatService.MessageReceived then
		okNew = true
		hookTextChatService()
	end
end)
if not okNew then
	hookLegacyChat()
end

-- === üìå Toggle Fluent UI ƒë·ªÉ ·∫©n/hi·ªán GUI chat ===
Tabs.Misc:AddToggle("CustomChatToggle", {
	Title = "Show Chat",
	Default = false,
}):OnChanged(function(enabled)
	if screenGui then
		screenGui.Enabled = enabled
	end
end)
end




-- Tabs.Settings


local AexecToggle = Tabs.Settings:AddToggle("AexecToggle", {Title = "Auto Execute", Default = false })
AexecToggle:OnChanged(function(Value)
    if Value then
        task.spawn(function()
            pcall(function()
                if queue_on_teleport then
                    local HutaoHubScript1 = [[
task.wait(3)
loadstring(game:HttpGet("https://raw.githubusercontent.com/hdksakst-ship-it/Hutao-Hub-Omega-X/refs/heads/main/Forsaken-v3.txt"))()
]]
                    queue_on_teleport(HutaoHubScript1)
                end
            end)
        end)
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is enabled!",
            Duration = 5
        })
    else
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is disabled!",
            Duration = 5
        })
    end
end)

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("Hutao HUB")
SaveManager:SetFolder("Hutao HUB/Forsaken")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Select First Tab By Default
Window:SelectTab(1)

Fluent:Notify({ Title = "Hutao HUB", Content = "forsaken script loaded successfully!", Duration = 5 })
SaveManager:LoadAutoloadConfig()


-- üü¢ DRAGGABLE UI BUTTON WITH ENHANCED CLICK AND HOVER ANIMATIONS
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local ExistingUI = CoreGui:FindFirstChild("HutaoHubMinimizeUI")
if ExistingUI then
    ExistingUI:Destroy()
end

-- Create Floating UI
local DragUI = Instance.new("ScreenGui")
DragUI.Name = "HutaoHubMinimizeUI"
DragUI.ResetOnSpawn = false
DragUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Ensures highest rendering priority
DragUI.Parent = CoreGui -- Overrides all other UI elements

-- Create Circular Button (Draggable + Clickable)
local Button = Instance.new("ImageButton")
Button.Parent = DragUI
Button.Size = UDim2.new(0, 50, 0, 50) -- Adjust size if needed
Button.Position = UDim2.new(0, 10, 1, -85) -- Initial position
Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Windows 11 Style
Button.BackgroundTransparency = 0.3 -- Semi-transparent
Button.BorderSizePixel = 0
Button.ClipsDescendants = true
Button.Image = "rbxassetid://90508203972003" -- Replace with your custom image ID
Button.ScaleType = Enum.ScaleType.Fit
Button.Active = true -- Allows drag functionality
Button.ZIndex = 1000 -- Ensure it stays on top

-- Make UI Circular
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0) -- Full circle
UICorner.Parent = Button

-- Tween Info for Animations
local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

-- Function to simulate RightShift key press
local function SimulateKeyPress()
    VirtualInputManager:SendKeyEvent(true, minimizeUI, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, minimizeUI, false, game)
end

-- Click Animation & UI Toggle (Only if NOT dragged too much)
local isDragging = false
local dragThreshold = 10 -- Allow small movement without canceling click

Button.MouseButton1Click:Connect(function()
    if isDragging then return end -- Prevent click after large dragging

    -- Enhanced Click Animation
    local tween = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.5,
        Size = UDim2.new(0, 45, 0, 45),
        Rotation = 5
    })
    tween:Play()
    task.wait(0.1)
    local tweenBack = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.3,
        Size = UDim2.new(0, 50, 0, 50),
        Rotation = 0
    })
    tweenBack:Play()

    -- Simulate RightShift to Toggle UI
    SimulateKeyPress()
end)

-- Hover Animation
Button.MouseEnter:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 55, 0, 55)}):Play()
end)

Button.MouseLeave:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 50, 0, 50)}):Play()
end)

-- Dragging Logic for PC & Mobile
local dragging, dragStart, startPos

local function StartDrag(input)
    isDragging = false -- Reset dragging state
    dragging = true
    dragStart = input.Position
    startPos = Button.Position

    input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
        end
    end)
end

local function OnDrag(input)
    if dragging then
        local delta = (input.Position - dragStart).Magnitude
        if delta > dragThreshold then -- Only mark as dragged if movement exceeds threshold
            isDragging = true
        end
        Button.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + (input.Position.X - dragStart.X),
            startPos.Y.Scale,
            startPos.Y.Offset + (input.Position.Y - dragStart.Y)
        )
    end
end

-- Dragging Support for PC & Mobile (on the same button)
Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        OnDrag(input)
    end
end)